<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="力扣题解," />










<meta name="description" content="【H】4. 寻找两个正序数组的中位数 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。  看到这个时间复杂度，说明应该用二分法 找中位数，实际上也就是找第k小数的另一种说法。假如两个数组的长度和为len，中位数应该是数组合并后第(len + 1) &#x2F; 2小的数和第(l">
<meta property="og:type" content="article">
<meta property="og:title" content="HOT100">
<meta property="og:url" content="http://hco3o.xyz/2022/03/28/HOT100/index.html">
<meta property="og:site_name" content="hco3o&#39;s blog">
<meta property="og:description" content="【H】4. 寻找两个正序数组的中位数 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。  看到这个时间复杂度，说明应该用二分法 找中位数，实际上也就是找第k小数的另一种说法。假如两个数组的长度和为len，中位数应该是数组合并后第(len + 1) &#x2F; 2小的数和第(l">
<meta property="og:locale">
<meta property="og:image" content="https://pic.leetcode-cn.com/735ea8129ab5b56b7058c6286217fa4bb5f8a198e4c8b2172fe0f75b29a966cd-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/09b8649cd2b8bbea74f7f632b098fed5f8404530ff44b5a0b54a360b3cf7dd8f-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/ad87d1f63a9bbd99e12605686290800ce61b03f9fb98d87f1d8c020d404421ac-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/e56a66ed318d1761cd8c8f9d1521f82a30c71ecc84f551912b90d8fe254c8f3d-image.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220314113416525.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/76574ab7ff2877d63b80a2d4f8496fab3c441065552edc562f62d5809e75e97e-Snipaste_2019-05-29_15-28-02.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/999e055b41e499d9ac704abada4a1b8e6697374fdfedc17d06b0e8aa10a8f8f6-287.png">
<meta property="article:published_time" content="2022-03-28T13:05:39.000Z">
<meta property="article:modified_time" content="2022-03-28T13:08:16.914Z">
<meta property="article:author" content="hco3o">
<meta property="article:tag" content="力扣题解">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.leetcode-cn.com/735ea8129ab5b56b7058c6286217fa4bb5f8a198e4c8b2172fe0f75b29a966cd-image.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hco3o.xyz/2022/03/28/HOT100/"/>





  <title>HOT100 | hco3o's blog</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hco3o's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hco3o.xyz/2022/03/28/HOT100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hco3o's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">HOT100</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-28T21:05:39+08:00">
                2022-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="【H】4-寻找两个正序数组的中位数"><a href="#【H】4-寻找两个正序数组的中位数" class="headerlink" title="【H】4. 寻找两个正序数组的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">【H】4. 寻找两个正序数组的中位数</a></h4><blockquote>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
</blockquote>
<p>看到这个时间复杂度，说明应该用二分法</p>
<p>找中位数，实际上也就是<code>找第k小数</code>的另一种说法。假如两个数组的长度和为<code>len</code>，中位数应该是数组合并后<strong>第<code>(len + 1) / 2</code>小的数</strong>和<strong>第<code>(len + 2) / 2</code>小的数</strong>的平均值</p>
<p>如何计算两个排序数组中的第k小的数？</p>
<p><img src="https://pic.leetcode-cn.com/735ea8129ab5b56b7058c6286217fa4bb5f8a198e4c8b2172fe0f75b29a966cd-image.png" alt="image.png"></p>
<p>假如要找第7小的数，先比较数组的前k / 2个数的大小，如图所示，这种情况下就可以排除第一个数组的前三个数，问题转化为：</p>
<p><img src="https://pic.leetcode-cn.com/09b8649cd2b8bbea74f7f632b098fed5f8404530ff44b5a0b54a360b3cf7dd8f-image.png" alt="image.png"></p>
<p>找<code>[1, 3, 4, 9]</code>和<code>[4, 5, 6, 7, 8, 9]</code>的第<code>4</code>小的数</p>
<p>假如数组长度小于<code>k / 2</code></p>
<p><img src="https://pic.leetcode-cn.com/ad87d1f63a9bbd99e12605686290800ce61b03f9fb98d87f1d8c020d404421ac-image.png" alt="image.png"></p>
<p>那么第一个数组待比较的数就是数组的最后一个元素(<code>index = start + Math.min(k / 2, length) - 1</code>)，如果这个数更小的话直接排除掉这个数组里的所有元素就行了，然后进行下一步递归判断数组长度为0，直接返回<code>nums2[start + k - 1]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> left = (m + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = (m + n + <span class="number">2</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) (getKthMin(nums1, <span class="number">0</span>, m - <span class="number">1</span>, nums2, <span class="number">0</span>, n - <span class="number">1</span>, left) + getKthMin(nums1, <span class="number">0</span>, m - <span class="number">1</span>, nums2, <span class="number">0</span>, n - <span class="number">1</span>, right)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回两个排序数组合并排序后第k小的数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKthMin</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[start1 + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKthMin(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKthMin(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】10-正则表达式匹配"><a href="#【H】10-正则表达式匹配" class="headerlink" title="【H】10. 正则表达式匹配"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">【H】10. 正则表达式匹配</a></h4><blockquote>
<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<ul>
<li><p><code>&#39;.&#39;</code> 匹配任意单个字符</p>
</li>
<li><p><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</p>
</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
</blockquote>
<p><strong><code>&#39;*&#39;</code>三种情况，非<code>&#39;*&#39;</code>两种情况</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length();</span><br><span class="line">        <span class="keyword">int</span> n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>] &amp;&amp; p.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>)) || (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] || (dp[i - <span class="number">1</span>][j] &amp;&amp; s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">2</span>)) || (dp[i - <span class="number">1</span>][j] &amp;&amp; p.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】22-括号生成"><a href="#【M】22-括号生成" class="headerlink" title="【M】22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">【M】22. 括号生成</a></h4><blockquote>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
</blockquote>
<p>递归函数里设置变量left、right表示当前字符串使用了多少个左括号和右括号。</p>
<ul>
<li>假如左括号和右括号个数都等于n，那么就把这个字符串放到集合里。</li>
<li>假如左括号数量小于右括号数量，不符合情况，直接返回</li>
<li>假如左括号数量小于n，就添加左括号。举个例子：当前字符串为<code>&quot;(&quot;, n=3</code>，添加左括号就是<code>&quot;((&quot;</code>，进入递归就可以得到以<code>&quot;((&quot;</code>开头的全部字符串：<code>&quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;</code>。递归结束后删掉最后一个字符串变为<code>&quot;(&quot;</code></li>
<li>假如右括号数量小于n，就添加右括号</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        backtracking(n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == left &amp;&amp; n == right) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; n) &#123;</span><br><span class="line">            path.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            backtracking(n, left + <span class="number">1</span>, right);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; n) &#123;</span><br><span class="line">            path.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            backtracking(n, left, right + <span class="number">1</span>);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】23-合并K个升序链表"><a href="#【H】23-合并K个升序链表" class="headerlink" title="【H】23. 合并K个升序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">【H】23. 合并K个升序链表</a></h4><blockquote>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
</blockquote>
<p>我想到的做法是使用<code>PriorityQueue</code>。还有一种做法是使用归并排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> lists[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(merge(lists, start, mid), merge(lists, mid + <span class="number">1</span>, end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode node1, ListNode node2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyNode = <span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode temp = dummyNode;</span><br><span class="line">    <span class="keyword">while</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node1.val &lt; node2.val) &#123;</span><br><span class="line">            temp.next = node1;</span><br><span class="line">            node1 = node1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        temp.next = node2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp.next = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】31-下一个排列"><a href="#【M】31-下一个排列" class="headerlink" title="【M】31. 下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-permutation/">【M】31. 下一个排列</a></h4><blockquote>
<p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li><p>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</p>
</li>
<li><p>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</p>
</li>
<li><p>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</p>
</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>
<p>必须**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地 </a>**修改，只允许使用额外常数空间。</p>
</blockquote>
<p>方法我其实是知道的：数组从后往前遍历，找到第一个<code>nums[i] &lt; nums[i + 1]</code>的点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    i--;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>注意while循环是<strong>大于等于</strong></p>
<p>假如循环结束<code>i = -1</code>就表示这个数组已经从大到小排好序了，直接reverse就是下一个排列</p>
<p>再从右往左找到第一个大于<code>nums[i]</code>的数，因为<code>i</code>后面的数都是从大到小排列的，从右往左第一个大于<code>nums[i]</code>的数一定是大于<code>nums[i]</code>的数里最小的那个。找到了之后把这两个数交换，然后把<code>[i + 1, nums.length - 1]</code>范围内的数<code>reverse</code>即可</p>
<p>我当初想的是把<code>i</code>后面的数排序（<code>sort</code>），后来看了题解才知道直接<code>reverse</code>就可以了，因为<code>reverse</code>之前<code>nums[i]</code>一定是在<code>[nums[j - 1], nums[j + 1]]</code>这个范围内的，也就是说交换之后后面的元素必为降序排列，不需要<code>sort</code>也能解决</p>
<p><img src="https://pic.leetcode-cn.com/e56a66ed318d1761cd8c8f9d1521f82a30c71ecc84f551912b90d8fe254c8f3d-image.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;</span><br><span class="line">            reverse(nums, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】39-组合总和"><a href="#【M】39-组合总和" class="headerlink" title="【M】39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">【M】39. 组合总和</a></h4><blockquote>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 <em>所有</em> <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
</blockquote>
<p>这是我写出来的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums, target - nums[i], start);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有几个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backtracking(nums, target - nums[i], start);</span><br></pre></td></tr></table></figure>

<p>这里向下回溯的起点不应该是<code>start</code>，而应该是<code>i</code>，因为假如选择的是start，可能当前循环i索引已经在后面了，不应该再考虑i索引之前的元素<code>nums[start]</code></p>
<p>在每个循环前最好加上一个判断语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (target - nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target - nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums, target - nums[i], i);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】42-接雨水"><a href="#【H】42-接雨水" class="headerlink" title="【H】42. 接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">【H】42. 接雨水</a></h4><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<ol>
<li><p>使用栈（时间复杂度O(n)，空间复杂度O(n)）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                count += (i - stack.peek() - <span class="number">1</span>) * (Math.min(height[i], height[stack.peek()]) - height[prev]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>双指针（时间复杂度O(n)，空间复杂度O(1)）</p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220314113416525.png" alt="image-20220314113416525"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">            res += Math.max(<span class="number">0</span>, leftMax - height[left]);</span><br><span class="line">            leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += Math.max(<span class="number">0</span>, rightMax - height[right]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="【M】49-字母异位词分组"><a href="#【M】49-字母异位词分组" class="headerlink" title="【M】49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams/">【M】49. 字母异位词分组</a></h4><blockquote>
<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
</blockquote>
<p>想到了按照每个字符串排序拼成一个key，value就是这个key所包含的所有字母异位词</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line">Arrays.sort(c);</span><br><span class="line">String key = Arrays.toString(c);</span><br></pre></td></tr></table></figure>

<p>其实有更简单的构造key的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">  count[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line">StringBuilder sbKey = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (count[i] != <span class="number">0</span>) &#123;</span><br><span class="line">    sbKey.append((<span class="keyword">char</span>) (i + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    sbKey.append(count[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后把<code>key</code>对应的<code>List&lt;String&gt;</code>取出来</p>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        count[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">      &#125;</span><br><span class="line">      StringBuilder sbKey = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[i] != <span class="number">0</span>) &#123;</span><br><span class="line">          sbKey.append((<span class="keyword">char</span>) (i + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">          sbKey.append(count[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String key = sbKey.toString();</span><br><span class="line">      List&lt;String&gt; value = map.getOrDefault(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">      value.add(str);</span><br><span class="line">      map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    map.forEach((key, value) -&gt; res.add(value));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】72-编辑距离"><a href="#【H】72-编辑距离" class="headerlink" title="【H】72. 编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">【H】72. 编辑距离</a></h4><p><img src="https://pic.leetcode-cn.com/76574ab7ff2877d63b80a2d4f8496fab3c441065552edc562f62d5809e75e97e-Snipaste_2019-05-29_15-28-02.png" alt="Snipaste_2019-05-29_15-28-02.png"></p>
<p>这题只有一点要注意的：假如<code>word1[i] == word2[j]</code>，那么<code>dp[i][j] = dp[i - 1][j - 1]</code></p>
<p>还有可以考虑空间优化（northwest）</p>
<h4 id="？【M】75-颜色分类"><a href="#？【M】75-颜色分类" class="headerlink" title="？【M】75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">？【M】75. 颜色分类</a></h4><blockquote>
<p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库的sort函数的情况下解决这个问题。</p>
</blockquote>
<p>设置两个指针<code>zero</code>、<code>two</code>表示<code>[0, zero)</code>全为<code>0</code>，<code>(two, nums.length - 1]</code>全为<code>2</code>，<code>zero</code>初始化为<code>0</code>，<code>two</code>初始化为<code>nums.length - 1</code></p>
<p>设置一个index开始遍历</p>
<p>分三种情况：</p>
<ul>
<li><code>nums[index] == 2</code>：此时<code>index &lt;= two</code>，先把这两个位置上的数交换，这个时候可以确定的是<code>two--</code>，但是<code>swap</code>之后从索引为<code>two</code>的位置换过来的数不能确定到底放在哪个位置，需要在下一个循环里判断，所以<code>index</code>不能<code>++</code></li>
<li><code>nums[index] == 0</code>：此时<code>zero &lt;= index</code>，先把这两个位置上的数交换，这个时候可以确定的是<code>zero++</code>。此时<code>index</code>也可以<code>++</code>，因为从zero位置换过来的元素。<strong>这里有个问题，为什么这里index可以直接++？</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> two = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= two) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, zero, index);</span><br><span class="line">                zero++;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] == <span class="number">1</span>) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(nums, index, two);</span><br><span class="line">                two--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】76-最小覆盖子串"><a href="#【H】76-最小覆盖子串" class="headerlink" title="【H】76. 最小覆盖子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">【H】76. 最小覆盖子串</a></h4><blockquote>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</p>
</li>
<li><p>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</p>
</li>
</ul>
</blockquote>
<p>设置一个长度为128的<code>need</code>数组存放当前滑动窗口还需要的元素个数，然后遍历<code>t</code>对其进行初始化。<code>count</code>设置为t的长度，表示滑动窗口中还需要多少个<code>t</code>中的字符。</p>
<p>进入while循环，假如right指针指向的字符在<code>need</code>数组中大于0，表示需要这个字符串，<code>count--</code>，无论count减不减，<code>need[s.charAt(right)]--</code>这一步操作都是要完成的，即使need值变为负数（表示这个字符是多余的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line"><span class="keyword">if</span> (need[c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br><span class="line">need[c]--;</span><br></pre></td></tr></table></figure>

<p>如果<code>count != 0</code>的话，直接<code>right++</code></p>
<p>直到<code>count == 0</code>，表示当前滑动窗口已经包含了t中的所有字符。</p>
<p>此时左指针不一定是起点，此时<code>need[s.charAt(left)]</code>可能小于0，移动左指针，直到<code>need[s.charAt(left)] == 0</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; need[s.charAt(left)] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    need[s.charAt(left)]++;</span><br><span class="line">    left++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，<code>[left, right]</code>就是<strong>以当前left开头的符合要求的最小子串</strong>，判断这个子串的长度是否为最小。判断结束后，left指针右移，在下一个循环中继续去寻找下一个left起点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">need[s.charAt(left)]++;</span><br><span class="line">left++;</span><br><span class="line">count++;</span><br></pre></td></tr></table></figure>

<p><strong>完整代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] need = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            need[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = t.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (need[c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            need[c]--;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; need[s.charAt(left)] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    need[s.charAt(left)]++;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; min) &#123;</span><br><span class="line">                    min = right - left + <span class="number">1</span>;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                need[s.charAt(left)]++;</span><br><span class="line">                left++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【E】94-二叉树的中序遍历"><a href="#【E】94-二叉树的中序遍历" class="headerlink" title="【E】94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">【E】94. 二叉树的中序遍历</a></h4><blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>
</blockquote>
<p>递归做法很简单，但是迭代利用辅助栈的做法还是不会</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】114-二叉树展开为链表"><a href="#【M】114-二叉树展开为链表" class="headerlink" title="【M】114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">【M】114. 二叉树展开为链表</a></h4><blockquote>
<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
</blockquote>
<p>递归：先把左右子树展开为链表，再把左子树接到右孩子，把右子树接到链表的末尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flatten(root.left);</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    TreeNode temp = root.right;</span><br><span class="line">    root.right = root.left;</span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    root.right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归：从根节点一直往右节点找，直到找到一个有左子树的root。然后从当前root的左孩子一直向右找，直到找到叶子节点。然后把root的右子树挂在叶子节点的右孩子位置。最后把root的左子树放到root的右孩子，左子树设为null，再继续向右找root</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode pre = root.left;</span><br><span class="line">            <span class="keyword">while</span> (pre.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre = pre.right;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.right = root.right;</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】124-二叉树中的最大路径和"><a href="#【H】124-二叉树中的最大路径和" class="headerlink" title="【H】124. 二叉树中的最大路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">【H】124. 二叉树中的最大路径和</a></h4><blockquote>
<p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> </p>
</blockquote>
<p>最关键的一步：<code>int dfs(TreeNode root)</code>表示root节点能为父节点提供的最大路径长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前节点能为父亲节点做的最大贡献</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = dfs(root.right);</span><br><span class="line">        max = Math.max(max, root.val + left + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="number">0</span>, root.val + Math.max(left, right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】128-最长连续序列"><a href="#【M】128-最长连续序列" class="headerlink" title="【M】128. 最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">【M】128. 最长连续序列</a></h4><blockquote>
<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
</blockquote>
<p>先把所有的数放到set里，方便第二次便利的时候判断当前数字会不会是连续节点的第一个数</p>
<p>然后第二遍遍历，假如<code>!set.contains(num - 1)</code>，就说明当前num可能是某个连续序列的第一个数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur = num;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (set.contains(cur + <span class="number">1</span>)) &#123;</span><br><span class="line">        cur++;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    max = Math.max(max, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = num;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (set.contains(cur + <span class="number">1</span>)) &#123;</span><br><span class="line">                    cur++;</span><br><span class="line">                    len++;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】148-排序链表"><a href="#【M】148-排序链表" class="headerlink" title="【M】148. 排序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-list/">【M】148. 排序链表</a></h4><blockquote>
<p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
</blockquote>
<p>这题要求使用空间复杂度<code>O(1)</code>，所以使用递归做法肯定就不行了。但是还是要使用归并排序。所以需要使用的是<strong>自底向上的归并</strong></p>
<p>首先算出链表的长度为<code>length</code></p>
<p>因为要自底向上，所以首先把长度为1的节点先排好序，也就是把列表切成若干个长度为1的单元，然后两两合并。切分长度首先设置为1，然后乘以二，长度为2、4、8，直到切分长度大于链表长度length的时候就退出。</p>
<p>首先在for循环外设置一个<code>dummyNode</code>，它的<code>next</code>指向头结点，这样最后<code>return</code>的时候方便</p>
<p>这里就设置一个for循环，每次循环指定一个切分长度。因为每次循环之前都是一个完整的链表：<code>dummyNode</code>后连着所有的节点。设置一个tail，表示已经排好序的链表的最后一个节点，初始化为<code>dummyNode</code>。设置一个cur，表示当前未排序链表的头结点，初始值设置为<code>dummyNode.next</code>。下面进入while循环，直到所有链表都排好（<code>cur != null</code>）。先设置<code>ListNode left = cur</code>，<code>ListNode right = cut(left, size)</code>，<code>cur = cut(right, size)</code>。然后把left和right排序，连在tail后面。最后把tail放到链表的末尾，结束本次while循环</p>
<blockquote>
<p><code>cut(ListNode head, int size)</code>的作用是返回以head为头节点的链表切掉size个节点之后的头节点，如果这个链表的长度小于等于size的话就返回null</p>
</blockquote>
<p>实际上每次for循环都是把旧链表的数据切割，然后连到一条新的链表上</p>
<p>for循环结束，返回<code>dummyNode.next</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">1</span>; size &lt; length; size &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ListNode tail = dummyNode;</span><br><span class="line">            ListNode cur = dummyNode.next;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode left = cur;</span><br><span class="line">                ListNode right = cut(left, size);</span><br><span class="line">                cur = cut(right, size);</span><br><span class="line">                tail.next = merge(left, right);</span><br><span class="line">                <span class="keyword">while</span> (tail.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    tail = tail.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">cut</span><span class="params">(ListNode node, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res = node.next;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode node1, ListNode node2)</span> </span>&#123;</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode temp = dummyNode;</span><br><span class="line">        <span class="keyword">while</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node1.val &lt; node2.val) &#123;</span><br><span class="line">                temp.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.next = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】152-乘积最大子数组"><a href="#【M】152-乘积最大子数组" class="headerlink" title="【M】152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/">【M】152. 乘积最大子数组</a></h4><blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p>
<p><strong>子数组</strong> 是数组的连续子序列。</p>
</blockquote>
<p>我知道要记录最大值和最小值。我的做法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preMax = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> preMin = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        preMax = Math.max(nums[i], Math.max(nums[i] * preMax, nums[i] * preMin));</span><br><span class="line">        preMin = Math.min(nums[i], Math.min(nums[i] * preMin, nums[i] * preMin));</span><br><span class="line">        max = Math.max(max, preMax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的做法应该是：</p>
<ul>
<li>令<code>preMax</code>为前面的最大值，则当前最大值为<code>preMax = Math.max(preMax * nums[i], nums[i])</code></li>
<li>由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值<code>preMin</code>，<code>preMin = Math.min(preMin * nums[i], nums[i])</code></li>
<li>当负数出现时则<code>preMax</code>与<code>preMin</code>进行交换再进行下一步计算</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preMax = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> preMin = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = preMax;</span><br><span class="line">            preMax = preMin;</span><br><span class="line">            preMin = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        preMax = Math.max(preMax * nums[i], nums[i]);</span><br><span class="line">        preMin = Math.min(preMin * nums[i], nums[i]);</span><br><span class="line">        max = Math.max(max, preMax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么当<code>nums[i] &lt; 0</code>的时候要交换<code>preMax</code>和<code>preMin</code>？</p>
</blockquote>
<p>因为当前数是负数，<code>preMin * nums[i]</code>肯定比<code>preMax * nums[i]</code>更大</p>
<h4 id="【M】221-最大正方形"><a href="#【M】221-最大正方形" class="headerlink" title="【M】221. 最大正方形"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-square/">【M】221. 最大正方形</a></h4><blockquote>
<p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p>
</blockquote>
<p>记录下以当前格子为右下角的最大正方形的边长即可</p>
<p>我没有考虑空间优化，因为需要取上面的格子、左边的格子和左上角的格子的数据。左上角格子的数据可以单独保存下来，这样就实现了空间优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        max = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            temp = dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = matrix[j][i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            max = Math.max(dp[<span class="number">0</span>], max);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (matrix[j][i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            temp = dp[j];</span><br><span class="line">            dp[j] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> northeast = dp[j];</span><br><span class="line">            dp[j] = Math.min(Math.min(dp[j], dp[j - <span class="number">1</span>]), temp) + <span class="number">1</span>;</span><br><span class="line">            max = Math.max(dp[j], max);</span><br><span class="line">            temp = northeast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【E】283-移动零"><a href="#【E】283-移动零" class="headerlink" title="【E】283. 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">【E】283. 移动零</a></h4><blockquote>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
</blockquote>
<p>两种做法：</p>
<ol>
<li><p>第一次遍历，每遇到一个非零元素就把它放到index位置，然后index++。第二次遍历把<code>[index, nums.length)</code>里的元素置零</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            nums[index] = nums[i];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历一次，设置快慢指针。快指针一直往前跑，遇到不是0的数就和慢指针交换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[fast];</span><br><span class="line">            nums[fast] = nums[slow];</span><br><span class="line">            nums[slow] = temp;</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="【M】287-寻找重复数"><a href="#【M】287-寻找重复数" class="headerlink" title="【M】287. 寻找重复数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">【M】287. 寻找重复数</a></h4><blockquote>
<p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>
<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p>
<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p>
</blockquote>
<p>假如不要求时间复杂度可以使用二分法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;            </span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; mid) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目要求时间复杂度O(N)</p>
<p>如果数组中有重复的数，以数组 [1,3,4,2,2] 为例,我们将数组下标 n 和数 nums[n] 建立一个映射关系 f(n)f(n)，<br>其映射关系 n-&gt;f(n) 为：<br>0-&gt;1<br>1-&gt;3<br>2-&gt;4<br>3-&gt;2<br>4-&gt;2<br>同样的，我们从下标为 0 出发，根据 f(n)f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推产生一个类似链表一样的序列。<br>0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;2-&gt;4-&gt;2-&gt;……<br>这里 2-&gt;4 是一个循环，那么这个链表可以抽象为下图：</p>
<p><img src="https://pic.leetcode-cn.com/999e055b41e499d9ac704abada4a1b8e6697374fdfedc17d06b0e8aa10a8f8f6-287.png" alt="287.png"></p>
<p>参考142题环形链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">    slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】300-最长递增子序列"><a href="#【M】300-最长递增子序列" class="headerlink" title="【M】300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">【M】300. 最长递增子序列</a></h4><blockquote>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
</blockquote>
<p><strong>关键</strong>：定义一个<code>tail</code>数组，<code>tail[i]</code>表示长度为<code>i + 1</code>的最长递增子序列的最小结尾数字</p>
<p><strong>注意</strong>：tail数组不表示所求的子序列</p>
<table>
<thead>
<tr>
<th align="center">10</th>
<th align="center">9</th>
<th align="center">2</th>
<th align="center">5</th>
<th align="center">3</th>
<th align="center">7</th>
<th align="center">101</th>
<th align="center">18</th>
<th align="center">4</th>
<th align="center">8</th>
<th align="center">6</th>
<th align="center">12</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">5</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">7</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">7</td>
<td align="center">101</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">7</td>
<td align="center">18</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">18</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">6</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">6</td>
<td align="center">12</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>res表示tail的最后一位的索引，初始化为-1，返回的时候返回<code>res + 1</code></p>
<p>遍历数组</p>
<ul>
<li><p>假如当前数字<code>nums[i]</code>比<code>tail</code>数组的最后一个数字（<code>res</code>索引指向的数）还大，直接放到tail后</p>
</li>
<li><p>假如当前数字<code>nums[i]</code>小于等于<code>tail</code>数组的最后一个数字，就需要把这个数字放到<code>tail</code>数组内。使用二分法查找插入位置：<strong>在有序数组 <code>tail</code> 中查找第 1 个等于大于 <code>num</code> 的那个数，试图让它变小</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">    right = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>完整代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tail[i]表示长度为(i + 1)的最长递增子序列的最小结尾数字</span></span><br><span class="line">        <span class="keyword">int</span>[] tail = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res == -<span class="number">1</span> || tail[res] &lt; nums[i]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                tail[res] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail[binary(tail, res, nums[i])] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找nums(0:right)中大于等于target的最小坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】301-删除无效的括号"><a href="#【H】301-删除无效的括号" class="headerlink" title="【H】301. 删除无效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">【H】301. 删除无效的括号</a></h4><blockquote>
<p>给你一个由若干括号和字母组成的字符串 <code>s</code> ，删除最小数量的无效括号，使得输入的字符串有效。</p>
<p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p>
</blockquote>
<p>遇到左括号<code>score + 1</code>，遇到右括号<code>score - 1</code>。对于一个合法的方案，最终的<code>score</code>必须为<code>0</code>。最大得分怎么计算？先遍历一遍，<code>maxScore = min(左括号数量, 右括号数量)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        leftScore++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        rightScore++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">maxScore = Math.min(leftScore, rightScore);</span><br></pre></td></tr></table></figure>

<p>遍历的过程中还可以把最大长度计算出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        leftLen++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftLen != <span class="number">0</span>) &#123;</span><br><span class="line">            leftLen--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rightLen++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">maxLen = s.length() - leftLen - rightLen;</span><br></pre></td></tr></table></figure>

<p>方便递归里的判断，只要是长度等于<code>maxLen</code>并且<code>score = 0</code>就可以加到集合里</p>
<hr>
<p>进入递归<code>void dfs(int start, int score, String path)</code>。</p>
<p>假如<code>score</code>比<code>0</code>小或者大于<code>maxScore</code>表示不符合条件直接返回。假如<code>start = s.length()</code>说明搜索结束，再判断是否满足条件可以加到集合里</p>
<p>假如start索引表示的字符<code>c</code>是<code>&quot;(&quot;</code>，这个时候字符串可加可不加左括号，进入递归。把加括号和不加括号的结果都求出来，右括号同理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs(start + <span class="number">1</span>, score, path);</span><br><span class="line">dfs(start + <span class="number">1</span>, score + <span class="number">1</span>, path + c);</span><br></pre></td></tr></table></figure>

<p>假如是字母，直接加就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(start + <span class="number">1</span>, score, path + c);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>完整代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">int</span> maxScore;</span><br><span class="line">    <span class="keyword">int</span> maxLen;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="keyword">int</span> leftScore = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightScore = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                leftScore++;</span><br><span class="line">                leftLen++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                rightScore++;</span><br><span class="line">                <span class="keyword">if</span> (leftLen != <span class="number">0</span>) &#123;</span><br><span class="line">                    leftLen--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    rightLen++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxScore = Math.min(leftScore, rightScore);</span><br><span class="line">        maxLen = s.length() - leftLen - rightLen;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> score, String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (score &lt; <span class="number">0</span> || score &gt; maxScore) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (score == <span class="number">0</span> &amp;&amp; path.length() == maxLen) &#123;</span><br><span class="line">                set.add(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(start);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            dfs(start + <span class="number">1</span>, score, path);</span><br><span class="line">            dfs(start + <span class="number">1</span>, score + <span class="number">1</span>, path + c);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            dfs(start + <span class="number">1</span>, score, path);</span><br><span class="line">            dfs(start + <span class="number">1</span>, score - <span class="number">1</span>, path + c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(start + <span class="number">1</span>, score, path + c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】416-分割等和子集"><a href="#【M】416-分割等和子集" class="headerlink" title="【M】416. 分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">【M】416. 分割等和子集</a></h4><blockquote>
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
</blockquote>
<p>先计算数组各个数相加的和为<code>sum</code>，假如<code>sum</code>不为<code>2</code>的倍数直接返回<code>false</code>。假如为<code>2</code>的倍数，就计算这些数能否选取一些数相加和为<code>sum / 2</code>。</p>
<p>动态规划：<code>dp[i][j]</code>表示选取<code>nums</code>前<code>[0, i]</code>（每个数只选一次）能否组成和为<code>j</code>的子集。</p>
<p>再考虑空间优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; sum / <span class="number">2</span>) &#123;</span><br><span class="line">            dp[nums[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sum / <span class="number">2</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dp[j] &amp;&amp; j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[j] = dp[j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == sum / <span class="number">2</span> &amp;&amp; dp[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】437-路径总和-III"><a href="#【M】437-路径总和-III" class="headerlink" title="【M】437. 路径总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">【M】437. 路径总和 III</a></h4><blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>
<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
</blockquote>
<p>大致上知道要用前缀和保存路径出现的次数，有几个小细节需要注意：</p>
<ol>
<li><p><code>map</code>初始化的时候往里加入<code>(0, 1)</code></p>
</li>
<li><p>进入<code>dfs</code>，在<code>path</code>加上当前节点的值后，先在<code>map</code>里找有没有值为<code>(path - target)</code>的键，再把当前路径加到<code>map</code>中（<strong>注意这个先后顺序</strong>，我就是在这里翻车的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count += map.getOrDefault(path - targetSum, <span class="number">0</span>);</span><br><span class="line">map.put(path, map.getOrDefault(path, <span class="number">0</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>为什么要遵循这样的顺序？因为map中存放的是<strong>前缀和</strong>，key保存的是就是从根节点到路径上前面这些节点的可能的和。假如<code>map</code>中含有<code>key = 8</code>，说明在这条从根节点到当前节点的路径上（不包括当前节点）存在路径为<code>8</code>的值。此时<code>path = 10</code>，<code>targetSum = 2</code>，那么就可以<code>count += map.get(key)</code>了</p>
<p>假如先put再count的话，就不符合前缀和的概念了。先put，就把当前节点算在内了</p>
</li>
</ol>
<p><strong>完整代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> targetSum;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.targetSum = targetSum;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path += root.val;</span><br><span class="line">        count += map.getOrDefault(path - targetSum, <span class="number">0</span>);</span><br><span class="line">        map.put(path, map.getOrDefault(path, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        map.put(path, map.get(path) - <span class="number">1</span>);</span><br><span class="line">        path -= root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】438-找到字符串中所有字母异位词"><a href="#【M】438-找到字符串中所有字母异位词" class="headerlink" title="【M】438. 找到字符串中所有字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">【M】438. 找到字符串中所有字母异位词</a></h4><blockquote>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
</blockquote>
<p>滑动窗口。</p>
<p>先把<code>p</code>的字母频次记录下来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">    pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后设置双指针遍历<code>s</code>字符串</p>
<p>假如<code>right</code>所指向字符的频次比要求的频次高，就一直把<code>left</code>指针右移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = s.charAt(right) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">sCount[index]++;</span><br><span class="line"><span class="keyword">while</span> (sCount[index] &gt; pCount[index]) &#123;</span><br><span class="line">    sCount[s.charAt(left) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    left++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳出循环后再判断长度是不是符合要求</p>
<p><strong>完整代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] sCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span>[] pCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">        pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = s.charAt(right) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        sCount[index]++;</span><br><span class="line">        <span class="keyword">while</span> (sCount[index] &gt; pCount[index]) &#123;</span><br><span class="line">            sCount[s.charAt(left) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> == p.length()) &#123;</span><br><span class="line">            res.add(left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么<code>left</code>一直右移？</p>
</blockquote>
<p>因为此时<code>right</code>所指的字符串的频次太高了，需要剔除掉窗口左侧多余的字符</p>
<h4 id="【E】461-汉明距离"><a href="#【E】461-汉明距离" class="headerlink" title="【E】461. 汉明距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hamming-distance/">【E】461. 汉明距离</a></h4><blockquote>
<p>两个整数之间的 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离</p>
</blockquote>
<p>我想到的做法是对x和y的每一位进行异或然后右移。实际上可以先把x和y异或的结果算出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = x ^ y;</span><br></pre></td></tr></table></figure>

<p>然后对这个值进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">    temp &amp;= (temp - <span class="number">1</span>);</span><br><span class="line">    res++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】494-目标和"><a href="#【M】494-目标和" class="headerlink" title="【M】494. 目标和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">【M】494. 目标和</a></h4><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
</blockquote>
<p>想到了要先算数组和sum，然后所有前面为减号的数据的和为<code>decr</code>，那么所有前面为加号的数据和为<code>sum - decr</code>，所以<code>sum - decr - decr = target</code>，<code>decr * 2 = sum - target</code>，如果<code>sum - target</code>不是<code>2</code>的倍数直接返回<code>0</code></p>
<p>问题转化为：从<code>nums</code>中选取若干数，求出和为<code>(sum - target) / 2</code>的方法个数</p>
<p>后面就出现了问题，没看清题目的条件（<code>nums[i] &gt;= 0</code>），导致新建<code>dp</code>数组的时候还考虑了负数。<code>dp[i][j]</code>表示取数组<code>[0, i]</code>中的元素，和为<code>j</code>的方法数</p>
<p>此外考虑空间优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">      sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((sum - target) % <span class="number">2</span> == <span class="number">1</span> || (sum - target) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> decr = (sum - target) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[decr + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; decr + <span class="number">1</span>) &#123;</span><br><span class="line">      dp[nums[<span class="number">0</span>]] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = decr; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">          dp[j] += dp[j - nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[decr];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】538-把二叉搜索树转换为累加树"><a href="#【M】538-把二叉搜索树转换为累加树" class="headerlink" title="【M】538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">【M】538. 把二叉搜索树转换为累加树</a></h4><blockquote>
<p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
</blockquote>
<p>递归的做法很容易想到，迭代不熟。参考二叉树中序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    TreeNode res = root;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.poll();</span><br><span class="line">        root.val += pre;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【E】543-二叉树的直径"><a href="#【E】543-二叉树的直径" class="headerlink" title="【E】543. 二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">【E】543. 二叉树的直径</a></h4><blockquote>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
</blockquote>
<p>我的想法是先<code>dfs</code>到每个节点然后分别计算每个节点的直径求出最大值。题解里有更简单的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        max = Math.max(max, left + right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【E】617-合并二叉树"><a href="#【E】617-合并二叉树" class="headerlink" title="【E】617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">【E】617. 合并二叉树</a></h4><blockquote>
<p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>
</blockquote>
<p>首先要清楚可以分为递归和迭代两种做法</p>
<p><strong>递归</strong></p>
<p>我想的递归是这样的：建立一颗新的树进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeNode newRoot = <span class="keyword">new</span> TreeNode(root1.val + root2.val);</span><br><span class="line">newRoot.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">newRoot.right = mergeTrees(root1.right, root2.right);</span><br></pre></td></tr></table></figure>

<p>其实有更简单的递归，直接在某一颗树上加值就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root1.val += root2.val;</span><br><span class="line">root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">root1.right = mergeTrees(root1.right, root2.right);</span><br></pre></td></tr></table></figure>

<p><strong>迭代</strong></p>
<p>迭代也是一样，在某棵树上进行操作。我的想法还是复杂了，想新建一棵树</p>
<p>首先把root1和root2放入队列。然后进入循环：</p>
<p><code>poll</code>两个节点为<code>cur1</code>和<code>cur2</code>，把两个节点的值相加（因为能放入队列的节点必不为空）。假如cur1和cur2的左节点都不为空，就把两个左节点放进队列；假如cur1的左节点为空，就直接把cur2的左节点挂在cur1上。右节点同理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root1);</span><br><span class="line">    queue.offer(root2);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node1 = queue.poll();</span><br><span class="line">        TreeNode node2 = queue.poll();</span><br><span class="line">        node1.val += node2.val;</span><br><span class="line">        <span class="keyword">if</span> (node1.left != <span class="keyword">null</span> &amp;&amp; node2.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node1.left);</span><br><span class="line">            queue.offer(node2.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node1.left = node2.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1.right != <span class="keyword">null</span> &amp;&amp; node2.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node1.right);</span><br><span class="line">            queue.offer(node2.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node1.right = node2.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/" rel="tag"># 力扣题解</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/03/28/LCOF/" rel="next" title="LCOF">
                <i class="fa fa-chevron-left"></i> LCOF
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/03/28/others/" rel="prev" title="others">
                others <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90H%E3%80%914-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">【H】4. 寻找两个正序数组的中位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90H%E3%80%9110-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">2.</span> <span class="nav-text">【H】10. 正则表达式匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%9122-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-number">3.</span> <span class="nav-text">【M】22. 括号生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90H%E3%80%9123-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">4.</span> <span class="nav-text">【H】23. 合并K个升序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%9131-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">【M】31. 下一个排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%9139-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">6.</span> <span class="nav-text">【M】39. 组合总和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90H%E3%80%9142-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-number">7.</span> <span class="nav-text">【H】42. 接雨水</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%9149-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="nav-number">8.</span> <span class="nav-text">【M】49. 字母异位词分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90H%E3%80%9172-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">9.</span> <span class="nav-text">【H】72. 编辑距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%9F%E3%80%90M%E3%80%9175-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="nav-number">10.</span> <span class="nav-text">？【M】75. 颜色分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90H%E3%80%9176-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="nav-number">11.</span> <span class="nav-text">【H】76. 最小覆盖子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90E%E3%80%9194-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">12.</span> <span class="nav-text">【E】94. 二叉树的中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%91114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-number">13.</span> <span class="nav-text">【M】114. 二叉树展开为链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90H%E3%80%91124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">14.</span> <span class="nav-text">【H】124. 二叉树中的最大路径和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%91128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="nav-number">15.</span> <span class="nav-text">【M】128. 最长连续序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%91148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">16.</span> <span class="nav-text">【M】148. 排序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%91152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">17.</span> <span class="nav-text">【M】152. 乘积最大子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%91221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number">18.</span> <span class="nav-text">【M】221. 最大正方形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90E%E3%80%91283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="nav-number">19.</span> <span class="nav-text">【E】283. 移动零</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%91287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="nav-number">20.</span> <span class="nav-text">【M】287. 寻找重复数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%91300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">21.</span> <span class="nav-text">【M】300. 最长递增子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90H%E3%80%91301-%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-number">22.</span> <span class="nav-text">【H】301. 删除无效的括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%91416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">23.</span> <span class="nav-text">【M】416. 分割等和子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%91437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="nav-number">24.</span> <span class="nav-text">【M】437. 路径总和 III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%91438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">25.</span> <span class="nav-text">【M】438. 找到字符串中所有字母异位词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90E%E3%80%91461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB"><span class="nav-number">26.</span> <span class="nav-text">【E】461. 汉明距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%91494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="nav-number">27.</span> <span class="nav-text">【M】494. 目标和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90M%E3%80%91538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="nav-number">28.</span> <span class="nav-text">【M】538. 把二叉搜索树转换为累加树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90E%E3%80%91543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">29.</span> <span class="nav-text">【E】543. 二叉树的直径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90E%E3%80%91617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">30.</span> <span class="nav-text">【E】617. 合并二叉树</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hco3o</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
