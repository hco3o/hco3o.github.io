<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="hco3o&#39;s blog">
<meta property="og:url" content="http://hco3o.xyz/index.html">
<meta property="og:site_name" content="hco3o&#39;s blog">
<meta property="og:locale">
<meta property="article:author" content="hco3o">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hco3o.xyz/"/>





  <title>hco3o's blog</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hco3o's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hco3o.xyz/2022/03/28/others/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hco3o's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/28/others/" itemprop="url">others</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-28T21:08:34+08:00">
                2022-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="【E】13-罗马数字转整数"><a href="#【E】13-罗马数字转整数" class="headerlink" title="【E】13. 罗马数字转整数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/roman-to-integer/">【E】13. 罗马数字转整数</a></h4><blockquote>
<p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 1 。<code>12</code> 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 <code>27</code> 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><p><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</p>
</li>
<li><p><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </p>
</li>
<li><p><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</p>
<p>给定一个罗马数字，将其转换成整数。</p>
</li>
</ul>
</blockquote>
<p>当前这个字符表示的数为num。设置一个pre，表示当前遍历到的字符的前一个字符表示的数</p>
<ul>
<li>如果num比pre要小或者等于pre，说明是正常顺序，直接加上pre就可以了</li>
<li>如果num比pre要大，说明是例如C(100)D(500)这种情况，此时要减去pre值</li>
</ul>
<p>每遍历完一个字符后把pre设为num然后遍历下一个字符</p>
<p>最后一个字符的值保存在了pre里，跳出循环后直接加上就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = map.get(s.charAt(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = map.get(s.charAt(i));</span><br><span class="line">        <span class="keyword">if</span> (pre &lt; num) &#123;</span><br><span class="line">            count -= pre;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count += pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = num;</span><br><span class="line">    &#125;</span><br><span class="line">    count += pre;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】24-两两交换链表中的节点"><a href="#【M】24-两两交换链表中的节点" class="headerlink" title="【M】24. 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">【M】24. 两两交换链表中的节点</a></h4><blockquote>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
</blockquote>
<p>迭代做法很简单</p>
<p>看看递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    head.next = swapPairs(head.next.next);</span><br><span class="line">    next.next = head;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】36-有效的数独"><a href="#【M】36-有效的数独" class="headerlink" title="【M】36. 有效的数独"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-sudoku/">【M】36. 有效的数独</a></h4><blockquote>
<p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要 <strong>根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>空白格用 <code>&#39;.&#39;</code> 表示。</li>
</ul>
</blockquote>
<p><strong>未优化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] row = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">boolean</span>[][] column = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">boolean</span>[][] square = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (row[i][index] || column[j][index] || square[(i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>][index]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                row[i][index] = <span class="keyword">true</span>;</span><br><span class="line">                column[j][index] = <span class="keyword">true</span>;</span><br><span class="line">                square[(i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>][index] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化后</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">int</span>[] column = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">int</span>[] square = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> ((row[i] &amp; (<span class="number">1</span> &lt;&lt; index)) != <span class="number">0</span> || (column[j] &amp; (<span class="number">1</span> &lt;&lt; index)) != <span class="number">0</span> || (square[(i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; index)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                row[i] |= <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">                column[j] |= <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">                square[(i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>] |= <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】89-格雷编码"><a href="#【M】89-格雷编码" class="headerlink" title="【M】89. 格雷编码"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gray-code/">【M】89. 格雷编码</a></h4><blockquote>
<p><strong>n 位格雷码序列</strong> 是一个由 <code>2n</code> 个整数组成的序列，其中：</p>
<ul>
<li><p>每个整数都在范围 <code>[0, 2n - 1]</code> 内（含 <code>0</code> 和 <code>2n - 1</code>）</p>
</li>
<li><p>第一个整数是 <code>0</code></p>
</li>
<li><p>一个整数在序列中出现 <strong>不超过一次</strong></p>
</li>
<li><p>每对 <strong>相邻</strong> 整数的二进制表示 <strong>恰好一位不同</strong> ，且</p>
</li>
<li><p><strong>第一个</strong> 和 <strong>最后一个</strong> 整数的二进制表示 <strong>恰好一位不同</strong></p>
</li>
</ul>
<p>给你一个整数 <code>n</code> ，返回任一有效的 <strong>n 位格雷码序列</strong> 。</p>
</blockquote>
<p>n = 3的时候，格雷编码序列为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span>, <span class="number">001</span>, <span class="number">011</span>, <span class="number">010</span>, <span class="number">110</span>, <span class="number">111</span>, <span class="number">101</span>, <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>前四个数和后四个数如果不算最高位的话是对称的</p>
<p>可以联想到从<code>n = 2</code>到<code>n = 3</code>的变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>, <span class="number">01</span>, <span class="number">11</span>, <span class="number">10</span>      ---&gt;      <span class="number">000</span>, <span class="number">001</span>, <span class="number">011</span>, <span class="number">010</span>, <span class="number">110</span>, <span class="number">111</span>, <span class="number">101</span>, <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>可以先从<code>n = 0</code>开始，初始化序列里放入<code>0</code>，然后循环<code>n</code>次</p>
<p>n = 0的时候，要做的事是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>      ---&gt;      <span class="number">0</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>设置最高位<code>head = 1</code>，每次循环后<code>head</code>左移一位</p>
<p>循环体内</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = res.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    res.add(head + res.get(j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前一个序列的末尾开始遍历，给每一个值加上head，相当于在最前面加了一个1</p>
<p>例如：第一次取出010，加了head变为110再放入序列；第二次取出011，加了head变为111再放入序列</p>
<p><strong>完整代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    res.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = res.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            res.add(head + res.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">        head &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【E】100-相同的树"><a href="#【E】100-相同的树" class="headerlink" title="【E】100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">【E】100. 相同的树</a></h4><blockquote>
<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
</blockquote>
<p>递归没什么好说的</p>
<p>迭代我使用了两个队列（<code>ArrayDeque</code>），可以简化为一个队列（使用<code>LinkedList</code>，可以存<code>null</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(p);</span><br><span class="line">    queue.offer(q);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur1 = queue.poll();</span><br><span class="line">        TreeNode cur2 = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (!(cur1 == <span class="keyword">null</span> &amp;&amp; cur2 == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1 == <span class="keyword">null</span> || cur2 == <span class="keyword">null</span> || cur1.val != cur2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(cur1.left);</span><br><span class="line">            queue.offer(cur2.left);</span><br><span class="line">            queue.offer(cur1.right);</span><br><span class="line">            queue.offer(cur2.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】135-分发糖果"><a href="#【H】135-分发糖果" class="headerlink" title="【H】135. 分发糖果"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/candy/">【H】135. 分发糖果</a></h4><blockquote>
<p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 <code>1</code> 个糖果。</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>
</blockquote>
<ul>
<li>左规则：<code>ratings[i] &gt; ratings[i - 1]</code>，<code>i</code>的糖果比<code>i - 1</code>的多</li>
<li>右规则：<code>ratings[i] &lt; ratings[i + 1]</code>，<code>i</code>的糖果比<code>i + 1</code>的少</li>
</ul>
<p>流程：</p>
<ul>
<li>从左往右遍历，假如当前孩子评分比前一个孩子评分高，当前孩子的糖比前一个孩子多一个；假如当前孩子评分等于或小于前一个孩子的评分，当前孩子分配一个糖。至于当前孩子比后一个孩子大还是小，比后一个孩子糖的数量是多还是少交给下一个循环判断</li>
<li>从右往左遍历，假如当前孩子评分比后一个孩子评分高，当前孩子的糖比后一个孩子多一个，否则当前孩子分配一个糖</li>
<li>最后取得left数组和right数组每个学生可能糖果的最大值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">    <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">    Arrays.fill(left, <span class="number">1</span>);</span><br><span class="line">    Arrays.fill(right, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = left[ratings.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            right[i] = right[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += Math.max(left[i], right[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间上可稍做优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = left[ratings.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += Math.max(left[i], right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>还有一种常数空间复杂度的解法，还没看</strong></p>
<h4 id="【E】144-二叉树的前序遍历"><a href="#【E】144-二叉树的前序遍历" class="headerlink" title="【E】144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">【E】144. 二叉树的前序遍历</a></h4><blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
</blockquote>
<p><img src="https://pic.leetcode-cn.com/6233a9685447d0b4d7b513f739151ca065e5697e24070bcafc1ee5d28f9155a6.png" alt="中序遍历流程图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        root = stack.poll();</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】162-寻找峰值"><a href="#【M】162-寻找峰值" class="headerlink" title="【M】162. 寻找峰值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-peak-element/">【M】162. 寻找峰值</a></h4><blockquote>
<p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p>
<p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p>
</blockquote>
<p>复杂度说明一定要用二分法</p>
<ul>
<li>假如<code>nums[mid] &gt; nums[mid + 1]</code>，说明<code>mid</code>有可能是峰值，<code>right = mid</code></li>
<li>另外一种情况只可能是<code>nums[mid] &lt; nums[mid + 1]</code>，<code>mid</code>不是峰值，<code>left = mid + 1</code></li>
</ul>
<p>要明确两点：</p>
<ul>
<li>数组一定有峰值，因为你无论怎么划分，<code>nums[-1]</code>和<code>nums[n]</code>都是<code>-∞</code></li>
<li>二分法不会漏掉峰值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】199-二叉树的右视图"><a href="#【M】199-二叉树的右视图" class="headerlink" title="【M】199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">【M】199. 二叉树的右视图</a></h4><blockquote>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
</blockquote>
<p>使用迭代很简单</p>
<p>递归：按照<strong>中右左</strong>的次序遍历，这样就能保证这一层里最优先遍历到的是最靠右的节点</p>
<p>关键点：假如当前的深度和list长度相等，表明这一层还没被遍历到。因为<strong>中右左</strong>的遍历次序已经可以保证每层最右边的节点优先遍历到了，所以当满足条件的时候就把当前节点值加入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (depth == res.size()) &#123;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完整代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth == res.size()) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">        dfs(root.right, depth);</span><br><span class="line">        dfs(root.left, depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hco3o.xyz/2022/03/28/HOT100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hco3o's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/28/HOT100/" itemprop="url">HOT100</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-28T21:05:39+08:00">
                2022-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="【H】4-寻找两个正序数组的中位数"><a href="#【H】4-寻找两个正序数组的中位数" class="headerlink" title="【H】4. 寻找两个正序数组的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">【H】4. 寻找两个正序数组的中位数</a></h4><blockquote>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
</blockquote>
<p>看到这个时间复杂度，说明应该用二分法</p>
<p>找中位数，实际上也就是<code>找第k小数</code>的另一种说法。假如两个数组的长度和为<code>len</code>，中位数应该是数组合并后<strong>第<code>(len + 1) / 2</code>小的数</strong>和<strong>第<code>(len + 2) / 2</code>小的数</strong>的平均值</p>
<p>如何计算两个排序数组中的第k小的数？</p>
<p><img src="https://pic.leetcode-cn.com/735ea8129ab5b56b7058c6286217fa4bb5f8a198e4c8b2172fe0f75b29a966cd-image.png" alt="image.png"></p>
<p>假如要找第7小的数，先比较数组的前k / 2个数的大小，如图所示，这种情况下就可以排除第一个数组的前三个数，问题转化为：</p>
<p><img src="https://pic.leetcode-cn.com/09b8649cd2b8bbea74f7f632b098fed5f8404530ff44b5a0b54a360b3cf7dd8f-image.png" alt="image.png"></p>
<p>找<code>[1, 3, 4, 9]</code>和<code>[4, 5, 6, 7, 8, 9]</code>的第<code>4</code>小的数</p>
<p>假如数组长度小于<code>k / 2</code></p>
<p><img src="https://pic.leetcode-cn.com/ad87d1f63a9bbd99e12605686290800ce61b03f9fb98d87f1d8c020d404421ac-image.png" alt="image.png"></p>
<p>那么第一个数组待比较的数就是数组的最后一个元素(<code>index = start + Math.min(k / 2, length) - 1</code>)，如果这个数更小的话直接排除掉这个数组里的所有元素就行了，然后进行下一步递归判断数组长度为0，直接返回<code>nums2[start + k - 1]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> left = (m + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = (m + n + <span class="number">2</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) (getKthMin(nums1, <span class="number">0</span>, m - <span class="number">1</span>, nums2, <span class="number">0</span>, n - <span class="number">1</span>, left) + getKthMin(nums1, <span class="number">0</span>, m - <span class="number">1</span>, nums2, <span class="number">0</span>, n - <span class="number">1</span>, right)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回两个排序数组合并排序后第k小的数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKthMin</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[start1 + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKthMin(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKthMin(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】10-正则表达式匹配"><a href="#【H】10-正则表达式匹配" class="headerlink" title="【H】10. 正则表达式匹配"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">【H】10. 正则表达式匹配</a></h4><blockquote>
<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<ul>
<li><p><code>&#39;.&#39;</code> 匹配任意单个字符</p>
</li>
<li><p><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</p>
</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
</blockquote>
<p><strong><code>&#39;*&#39;</code>三种情况，非<code>&#39;*&#39;</code>两种情况</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length();</span><br><span class="line">        <span class="keyword">int</span> n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>] &amp;&amp; p.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>)) || (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] || (dp[i - <span class="number">1</span>][j] &amp;&amp; s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">2</span>)) || (dp[i - <span class="number">1</span>][j] &amp;&amp; p.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】22-括号生成"><a href="#【M】22-括号生成" class="headerlink" title="【M】22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">【M】22. 括号生成</a></h4><blockquote>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
</blockquote>
<p>递归函数里设置变量left、right表示当前字符串使用了多少个左括号和右括号。</p>
<ul>
<li>假如左括号和右括号个数都等于n，那么就把这个字符串放到集合里。</li>
<li>假如左括号数量小于右括号数量，不符合情况，直接返回</li>
<li>假如左括号数量小于n，就添加左括号。举个例子：当前字符串为<code>&quot;(&quot;, n=3</code>，添加左括号就是<code>&quot;((&quot;</code>，进入递归就可以得到以<code>&quot;((&quot;</code>开头的全部字符串：<code>&quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;</code>。递归结束后删掉最后一个字符串变为<code>&quot;(&quot;</code></li>
<li>假如右括号数量小于n，就添加右括号</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        backtracking(n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == left &amp;&amp; n == right) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; n) &#123;</span><br><span class="line">            path.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            backtracking(n, left + <span class="number">1</span>, right);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; n) &#123;</span><br><span class="line">            path.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            backtracking(n, left, right + <span class="number">1</span>);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】23-合并K个升序链表"><a href="#【H】23-合并K个升序链表" class="headerlink" title="【H】23. 合并K个升序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">【H】23. 合并K个升序链表</a></h4><blockquote>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
</blockquote>
<p>我想到的做法是使用<code>PriorityQueue</code>。还有一种做法是使用归并排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> lists[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(merge(lists, start, mid), merge(lists, mid + <span class="number">1</span>, end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode node1, ListNode node2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyNode = <span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode temp = dummyNode;</span><br><span class="line">    <span class="keyword">while</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node1.val &lt; node2.val) &#123;</span><br><span class="line">            temp.next = node1;</span><br><span class="line">            node1 = node1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        temp.next = node2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp.next = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】31-下一个排列"><a href="#【M】31-下一个排列" class="headerlink" title="【M】31. 下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-permutation/">【M】31. 下一个排列</a></h4><blockquote>
<p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li><p>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</p>
</li>
<li><p>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</p>
</li>
<li><p>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</p>
</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>
<p>必须**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地 </a>**修改，只允许使用额外常数空间。</p>
</blockquote>
<p>方法我其实是知道的：数组从后往前遍历，找到第一个<code>nums[i] &lt; nums[i + 1]</code>的点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    i--;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>注意while循环是<strong>大于等于</strong></p>
<p>假如循环结束<code>i = -1</code>就表示这个数组已经从大到小排好序了，直接reverse就是下一个排列</p>
<p>再从右往左找到第一个大于<code>nums[i]</code>的数，因为<code>i</code>后面的数都是从大到小排列的，从右往左第一个大于<code>nums[i]</code>的数一定是大于<code>nums[i]</code>的数里最小的那个。找到了之后把这两个数交换，然后把<code>[i + 1, nums.length - 1]</code>范围内的数<code>reverse</code>即可</p>
<p>我当初想的是把<code>i</code>后面的数排序（<code>sort</code>），后来看了题解才知道直接<code>reverse</code>就可以了，因为<code>reverse</code>之前<code>nums[i]</code>一定是在<code>[nums[j - 1], nums[j + 1]]</code>这个范围内的，也就是说交换之后后面的元素必为降序排列，不需要<code>sort</code>也能解决</p>
<p><img src="https://pic.leetcode-cn.com/e56a66ed318d1761cd8c8f9d1521f82a30c71ecc84f551912b90d8fe254c8f3d-image.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;</span><br><span class="line">            reverse(nums, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】39-组合总和"><a href="#【M】39-组合总和" class="headerlink" title="【M】39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">【M】39. 组合总和</a></h4><blockquote>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 <em>所有</em> <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
</blockquote>
<p>这是我写出来的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums, target - nums[i], start);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有几个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backtracking(nums, target - nums[i], start);</span><br></pre></td></tr></table></figure>

<p>这里向下回溯的起点不应该是<code>start</code>，而应该是<code>i</code>，因为假如选择的是start，可能当前循环i索引已经在后面了，不应该再考虑i索引之前的元素<code>nums[start]</code></p>
<p>在每个循环前最好加上一个判断语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (target - nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target - nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums, target - nums[i], i);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】42-接雨水"><a href="#【H】42-接雨水" class="headerlink" title="【H】42. 接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">【H】42. 接雨水</a></h4><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<ol>
<li><p>使用栈（时间复杂度O(n)，空间复杂度O(n)）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                count += (i - stack.peek() - <span class="number">1</span>) * (Math.min(height[i], height[stack.peek()]) - height[prev]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>双指针（时间复杂度O(n)，空间复杂度O(1)）</p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220314113416525.png" alt="image-20220314113416525"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">            res += Math.max(<span class="number">0</span>, leftMax - height[left]);</span><br><span class="line">            leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += Math.max(<span class="number">0</span>, rightMax - height[right]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="【M】49-字母异位词分组"><a href="#【M】49-字母异位词分组" class="headerlink" title="【M】49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams/">【M】49. 字母异位词分组</a></h4><blockquote>
<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
</blockquote>
<p>想到了按照每个字符串排序拼成一个key，value就是这个key所包含的所有字母异位词</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line">Arrays.sort(c);</span><br><span class="line">String key = Arrays.toString(c);</span><br></pre></td></tr></table></figure>

<p>其实有更简单的构造key的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">  count[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line">StringBuilder sbKey = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (count[i] != <span class="number">0</span>) &#123;</span><br><span class="line">    sbKey.append((<span class="keyword">char</span>) (i + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    sbKey.append(count[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后把<code>key</code>对应的<code>List&lt;String&gt;</code>取出来</p>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        count[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">      &#125;</span><br><span class="line">      StringBuilder sbKey = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[i] != <span class="number">0</span>) &#123;</span><br><span class="line">          sbKey.append((<span class="keyword">char</span>) (i + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">          sbKey.append(count[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String key = sbKey.toString();</span><br><span class="line">      List&lt;String&gt; value = map.getOrDefault(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">      value.add(str);</span><br><span class="line">      map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    map.forEach((key, value) -&gt; res.add(value));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】72-编辑距离"><a href="#【H】72-编辑距离" class="headerlink" title="【H】72. 编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">【H】72. 编辑距离</a></h4><p><img src="https://pic.leetcode-cn.com/76574ab7ff2877d63b80a2d4f8496fab3c441065552edc562f62d5809e75e97e-Snipaste_2019-05-29_15-28-02.png" alt="Snipaste_2019-05-29_15-28-02.png"></p>
<p>这题只有一点要注意的：假如<code>word1[i] == word2[j]</code>，那么<code>dp[i][j] = dp[i - 1][j - 1]</code></p>
<p>还有可以考虑空间优化（northwest）</p>
<h4 id="？【M】75-颜色分类"><a href="#？【M】75-颜色分类" class="headerlink" title="？【M】75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">？【M】75. 颜色分类</a></h4><blockquote>
<p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库的sort函数的情况下解决这个问题。</p>
</blockquote>
<p>设置两个指针<code>zero</code>、<code>two</code>表示<code>[0, zero)</code>全为<code>0</code>，<code>(two, nums.length - 1]</code>全为<code>2</code>，<code>zero</code>初始化为<code>0</code>，<code>two</code>初始化为<code>nums.length - 1</code></p>
<p>设置一个index开始遍历</p>
<p>分三种情况：</p>
<ul>
<li><code>nums[index] == 2</code>：此时<code>index &lt;= two</code>，先把这两个位置上的数交换，这个时候可以确定的是<code>two--</code>，但是<code>swap</code>之后从索引为<code>two</code>的位置换过来的数不能确定到底放在哪个位置，需要在下一个循环里判断，所以<code>index</code>不能<code>++</code></li>
<li><code>nums[index] == 0</code>：此时<code>zero &lt;= index</code>，先把这两个位置上的数交换，这个时候可以确定的是<code>zero++</code>。此时<code>index</code>也可以<code>++</code>，因为从zero位置换过来的元素。<strong>这里有个问题，为什么这里index可以直接++？</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> two = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= two) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, zero, index);</span><br><span class="line">                zero++;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] == <span class="number">1</span>) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(nums, index, two);</span><br><span class="line">                two--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】76-最小覆盖子串"><a href="#【H】76-最小覆盖子串" class="headerlink" title="【H】76. 最小覆盖子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">【H】76. 最小覆盖子串</a></h4><blockquote>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</p>
</li>
<li><p>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</p>
</li>
</ul>
</blockquote>
<p>设置一个长度为128的<code>need</code>数组存放当前滑动窗口还需要的元素个数，然后遍历<code>t</code>对其进行初始化。<code>count</code>设置为t的长度，表示滑动窗口中还需要多少个<code>t</code>中的字符。</p>
<p>进入while循环，假如right指针指向的字符在<code>need</code>数组中大于0，表示需要这个字符串，<code>count--</code>，无论count减不减，<code>need[s.charAt(right)]--</code>这一步操作都是要完成的，即使need值变为负数（表示这个字符是多余的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line"><span class="keyword">if</span> (need[c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br><span class="line">need[c]--;</span><br></pre></td></tr></table></figure>

<p>如果<code>count != 0</code>的话，直接<code>right++</code></p>
<p>直到<code>count == 0</code>，表示当前滑动窗口已经包含了t中的所有字符。</p>
<p>此时左指针不一定是起点，此时<code>need[s.charAt(left)]</code>可能小于0，移动左指针，直到<code>need[s.charAt(left)] == 0</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; need[s.charAt(left)] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    need[s.charAt(left)]++;</span><br><span class="line">    left++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，<code>[left, right]</code>就是<strong>以当前left开头的符合要求的最小子串</strong>，判断这个子串的长度是否为最小。判断结束后，left指针右移，在下一个循环中继续去寻找下一个left起点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">need[s.charAt(left)]++;</span><br><span class="line">left++;</span><br><span class="line">count++;</span><br></pre></td></tr></table></figure>

<p><strong>完整代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] need = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            need[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = t.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (need[c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            need[c]--;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; need[s.charAt(left)] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    need[s.charAt(left)]++;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; min) &#123;</span><br><span class="line">                    min = right - left + <span class="number">1</span>;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                need[s.charAt(left)]++;</span><br><span class="line">                left++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【E】94-二叉树的中序遍历"><a href="#【E】94-二叉树的中序遍历" class="headerlink" title="【E】94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">【E】94. 二叉树的中序遍历</a></h4><blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>
</blockquote>
<p>递归做法很简单，但是迭代利用辅助栈的做法还是不会</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】114-二叉树展开为链表"><a href="#【M】114-二叉树展开为链表" class="headerlink" title="【M】114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">【M】114. 二叉树展开为链表</a></h4><blockquote>
<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
</blockquote>
<p>递归：先把左右子树展开为链表，再把左子树接到右孩子，把右子树接到链表的末尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flatten(root.left);</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    TreeNode temp = root.right;</span><br><span class="line">    root.right = root.left;</span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    root.right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归：从根节点一直往右节点找，直到找到一个有左子树的root。然后从当前root的左孩子一直向右找，直到找到叶子节点。然后把root的右子树挂在叶子节点的右孩子位置。最后把root的左子树放到root的右孩子，左子树设为null，再继续向右找root</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode pre = root.left;</span><br><span class="line">            <span class="keyword">while</span> (pre.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre = pre.right;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.right = root.right;</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】124-二叉树中的最大路径和"><a href="#【H】124-二叉树中的最大路径和" class="headerlink" title="【H】124. 二叉树中的最大路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">【H】124. 二叉树中的最大路径和</a></h4><blockquote>
<p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> </p>
</blockquote>
<p>最关键的一步：<code>int dfs(TreeNode root)</code>表示root节点能为父节点提供的最大路径长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前节点能为父亲节点做的最大贡献</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = dfs(root.right);</span><br><span class="line">        max = Math.max(max, root.val + left + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="number">0</span>, root.val + Math.max(left, right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】128-最长连续序列"><a href="#【M】128-最长连续序列" class="headerlink" title="【M】128. 最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">【M】128. 最长连续序列</a></h4><blockquote>
<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
</blockquote>
<p>先把所有的数放到set里，方便第二次便利的时候判断当前数字会不会是连续节点的第一个数</p>
<p>然后第二遍遍历，假如<code>!set.contains(num - 1)</code>，就说明当前num可能是某个连续序列的第一个数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur = num;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (set.contains(cur + <span class="number">1</span>)) &#123;</span><br><span class="line">        cur++;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    max = Math.max(max, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = num;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (set.contains(cur + <span class="number">1</span>)) &#123;</span><br><span class="line">                    cur++;</span><br><span class="line">                    len++;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】148-排序链表"><a href="#【M】148-排序链表" class="headerlink" title="【M】148. 排序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-list/">【M】148. 排序链表</a></h4><blockquote>
<p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
</blockquote>
<p>这题要求使用空间复杂度<code>O(1)</code>，所以使用递归做法肯定就不行了。但是还是要使用归并排序。所以需要使用的是<strong>自底向上的归并</strong></p>
<p>首先算出链表的长度为<code>length</code></p>
<p>因为要自底向上，所以首先把长度为1的节点先排好序，也就是把列表切成若干个长度为1的单元，然后两两合并。切分长度首先设置为1，然后乘以二，长度为2、4、8，直到切分长度大于链表长度length的时候就退出。</p>
<p>首先在for循环外设置一个<code>dummyNode</code>，它的<code>next</code>指向头结点，这样最后<code>return</code>的时候方便</p>
<p>这里就设置一个for循环，每次循环指定一个切分长度。因为每次循环之前都是一个完整的链表：<code>dummyNode</code>后连着所有的节点。设置一个tail，表示已经排好序的链表的最后一个节点，初始化为<code>dummyNode</code>。设置一个cur，表示当前未排序链表的头结点，初始值设置为<code>dummyNode.next</code>。下面进入while循环，直到所有链表都排好（<code>cur != null</code>）。先设置<code>ListNode left = cur</code>，<code>ListNode right = cut(left, size)</code>，<code>cur = cut(right, size)</code>。然后把left和right排序，连在tail后面。最后把tail放到链表的末尾，结束本次while循环</p>
<blockquote>
<p><code>cut(ListNode head, int size)</code>的作用是返回以head为头节点的链表切掉size个节点之后的头节点，如果这个链表的长度小于等于size的话就返回null</p>
</blockquote>
<p>实际上每次for循环都是把旧链表的数据切割，然后连到一条新的链表上</p>
<p>for循环结束，返回<code>dummyNode.next</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">1</span>; size &lt; length; size &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ListNode tail = dummyNode;</span><br><span class="line">            ListNode cur = dummyNode.next;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode left = cur;</span><br><span class="line">                ListNode right = cut(left, size);</span><br><span class="line">                cur = cut(right, size);</span><br><span class="line">                tail.next = merge(left, right);</span><br><span class="line">                <span class="keyword">while</span> (tail.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    tail = tail.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">cut</span><span class="params">(ListNode node, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res = node.next;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode node1, ListNode node2)</span> </span>&#123;</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode temp = dummyNode;</span><br><span class="line">        <span class="keyword">while</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node1.val &lt; node2.val) &#123;</span><br><span class="line">                temp.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.next = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】152-乘积最大子数组"><a href="#【M】152-乘积最大子数组" class="headerlink" title="【M】152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/">【M】152. 乘积最大子数组</a></h4><blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p>
<p><strong>子数组</strong> 是数组的连续子序列。</p>
</blockquote>
<p>我知道要记录最大值和最小值。我的做法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preMax = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> preMin = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        preMax = Math.max(nums[i], Math.max(nums[i] * preMax, nums[i] * preMin));</span><br><span class="line">        preMin = Math.min(nums[i], Math.min(nums[i] * preMin, nums[i] * preMin));</span><br><span class="line">        max = Math.max(max, preMax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的做法应该是：</p>
<ul>
<li>令<code>preMax</code>为前面的最大值，则当前最大值为<code>preMax = Math.max(preMax * nums[i], nums[i])</code></li>
<li>由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值<code>preMin</code>，<code>preMin = Math.min(preMin * nums[i], nums[i])</code></li>
<li>当负数出现时则<code>preMax</code>与<code>preMin</code>进行交换再进行下一步计算</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preMax = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> preMin = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = preMax;</span><br><span class="line">            preMax = preMin;</span><br><span class="line">            preMin = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        preMax = Math.max(preMax * nums[i], nums[i]);</span><br><span class="line">        preMin = Math.min(preMin * nums[i], nums[i]);</span><br><span class="line">        max = Math.max(max, preMax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么当<code>nums[i] &lt; 0</code>的时候要交换<code>preMax</code>和<code>preMin</code>？</p>
</blockquote>
<p>因为当前数是负数，<code>preMin * nums[i]</code>肯定比<code>preMax * nums[i]</code>更大</p>
<h4 id="【M】221-最大正方形"><a href="#【M】221-最大正方形" class="headerlink" title="【M】221. 最大正方形"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-square/">【M】221. 最大正方形</a></h4><blockquote>
<p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p>
</blockquote>
<p>记录下以当前格子为右下角的最大正方形的边长即可</p>
<p>我没有考虑空间优化，因为需要取上面的格子、左边的格子和左上角的格子的数据。左上角格子的数据可以单独保存下来，这样就实现了空间优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        max = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            temp = dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = matrix[j][i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            max = Math.max(dp[<span class="number">0</span>], max);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (matrix[j][i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            temp = dp[j];</span><br><span class="line">            dp[j] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> northeast = dp[j];</span><br><span class="line">            dp[j] = Math.min(Math.min(dp[j], dp[j - <span class="number">1</span>]), temp) + <span class="number">1</span>;</span><br><span class="line">            max = Math.max(dp[j], max);</span><br><span class="line">            temp = northeast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【E】283-移动零"><a href="#【E】283-移动零" class="headerlink" title="【E】283. 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">【E】283. 移动零</a></h4><blockquote>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
</blockquote>
<p>两种做法：</p>
<ol>
<li><p>第一次遍历，每遇到一个非零元素就把它放到index位置，然后index++。第二次遍历把<code>[index, nums.length)</code>里的元素置零</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            nums[index] = nums[i];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历一次，设置快慢指针。快指针一直往前跑，遇到不是0的数就和慢指针交换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[fast];</span><br><span class="line">            nums[fast] = nums[slow];</span><br><span class="line">            nums[slow] = temp;</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="【M】287-寻找重复数"><a href="#【M】287-寻找重复数" class="headerlink" title="【M】287. 寻找重复数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">【M】287. 寻找重复数</a></h4><blockquote>
<p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>
<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p>
<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p>
</blockquote>
<p>假如不要求时间复杂度可以使用二分法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;            </span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; mid) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目要求时间复杂度O(N)</p>
<p>如果数组中有重复的数，以数组 [1,3,4,2,2] 为例,我们将数组下标 n 和数 nums[n] 建立一个映射关系 f(n)f(n)，<br>其映射关系 n-&gt;f(n) 为：<br>0-&gt;1<br>1-&gt;3<br>2-&gt;4<br>3-&gt;2<br>4-&gt;2<br>同样的，我们从下标为 0 出发，根据 f(n)f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推产生一个类似链表一样的序列。<br>0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;2-&gt;4-&gt;2-&gt;……<br>这里 2-&gt;4 是一个循环，那么这个链表可以抽象为下图：</p>
<p><img src="https://pic.leetcode-cn.com/999e055b41e499d9ac704abada4a1b8e6697374fdfedc17d06b0e8aa10a8f8f6-287.png" alt="287.png"></p>
<p>参考142题环形链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">    slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】300-最长递增子序列"><a href="#【M】300-最长递增子序列" class="headerlink" title="【M】300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">【M】300. 最长递增子序列</a></h4><blockquote>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
</blockquote>
<p><strong>关键</strong>：定义一个<code>tail</code>数组，<code>tail[i]</code>表示长度为<code>i + 1</code>的最长递增子序列的最小结尾数字</p>
<p><strong>注意</strong>：tail数组不表示所求的子序列</p>
<table>
<thead>
<tr>
<th align="center">10</th>
<th align="center">9</th>
<th align="center">2</th>
<th align="center">5</th>
<th align="center">3</th>
<th align="center">7</th>
<th align="center">101</th>
<th align="center">18</th>
<th align="center">4</th>
<th align="center">8</th>
<th align="center">6</th>
<th align="center">12</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">5</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">7</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">7</td>
<td align="center">101</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">7</td>
<td align="center">18</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">18</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">6</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">6</td>
<td align="center">12</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>res表示tail的最后一位的索引，初始化为-1，返回的时候返回<code>res + 1</code></p>
<p>遍历数组</p>
<ul>
<li><p>假如当前数字<code>nums[i]</code>比<code>tail</code>数组的最后一个数字（<code>res</code>索引指向的数）还大，直接放到tail后</p>
</li>
<li><p>假如当前数字<code>nums[i]</code>小于等于<code>tail</code>数组的最后一个数字，就需要把这个数字放到<code>tail</code>数组内。使用二分法查找插入位置：<strong>在有序数组 <code>tail</code> 中查找第 1 个等于大于 <code>num</code> 的那个数，试图让它变小</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">    right = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>完整代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tail[i]表示长度为(i + 1)的最长递增子序列的最小结尾数字</span></span><br><span class="line">        <span class="keyword">int</span>[] tail = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res == -<span class="number">1</span> || tail[res] &lt; nums[i]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                tail[res] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail[binary(tail, res, nums[i])] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找nums(0:right)中大于等于target的最小坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【H】301-删除无效的括号"><a href="#【H】301-删除无效的括号" class="headerlink" title="【H】301. 删除无效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">【H】301. 删除无效的括号</a></h4><blockquote>
<p>给你一个由若干括号和字母组成的字符串 <code>s</code> ，删除最小数量的无效括号，使得输入的字符串有效。</p>
<p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p>
</blockquote>
<p>遇到左括号<code>score + 1</code>，遇到右括号<code>score - 1</code>。对于一个合法的方案，最终的<code>score</code>必须为<code>0</code>。最大得分怎么计算？先遍历一遍，<code>maxScore = min(左括号数量, 右括号数量)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        leftScore++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        rightScore++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">maxScore = Math.min(leftScore, rightScore);</span><br></pre></td></tr></table></figure>

<p>遍历的过程中还可以把最大长度计算出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        leftLen++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftLen != <span class="number">0</span>) &#123;</span><br><span class="line">            leftLen--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rightLen++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">maxLen = s.length() - leftLen - rightLen;</span><br></pre></td></tr></table></figure>

<p>方便递归里的判断，只要是长度等于<code>maxLen</code>并且<code>score = 0</code>就可以加到集合里</p>
<hr>
<p>进入递归<code>void dfs(int start, int score, String path)</code>。</p>
<p>假如<code>score</code>比<code>0</code>小或者大于<code>maxScore</code>表示不符合条件直接返回。假如<code>start = s.length()</code>说明搜索结束，再判断是否满足条件可以加到集合里</p>
<p>假如start索引表示的字符<code>c</code>是<code>&quot;(&quot;</code>，这个时候字符串可加可不加左括号，进入递归。把加括号和不加括号的结果都求出来，右括号同理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs(start + <span class="number">1</span>, score, path);</span><br><span class="line">dfs(start + <span class="number">1</span>, score + <span class="number">1</span>, path + c);</span><br></pre></td></tr></table></figure>

<p>假如是字母，直接加就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(start + <span class="number">1</span>, score, path + c);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>完整代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">int</span> maxScore;</span><br><span class="line">    <span class="keyword">int</span> maxLen;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="keyword">int</span> leftScore = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightScore = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                leftScore++;</span><br><span class="line">                leftLen++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                rightScore++;</span><br><span class="line">                <span class="keyword">if</span> (leftLen != <span class="number">0</span>) &#123;</span><br><span class="line">                    leftLen--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    rightLen++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxScore = Math.min(leftScore, rightScore);</span><br><span class="line">        maxLen = s.length() - leftLen - rightLen;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> score, String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (score &lt; <span class="number">0</span> || score &gt; maxScore) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (score == <span class="number">0</span> &amp;&amp; path.length() == maxLen) &#123;</span><br><span class="line">                set.add(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(start);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            dfs(start + <span class="number">1</span>, score, path);</span><br><span class="line">            dfs(start + <span class="number">1</span>, score + <span class="number">1</span>, path + c);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            dfs(start + <span class="number">1</span>, score, path);</span><br><span class="line">            dfs(start + <span class="number">1</span>, score - <span class="number">1</span>, path + c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(start + <span class="number">1</span>, score, path + c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】416-分割等和子集"><a href="#【M】416-分割等和子集" class="headerlink" title="【M】416. 分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">【M】416. 分割等和子集</a></h4><blockquote>
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
</blockquote>
<p>先计算数组各个数相加的和为<code>sum</code>，假如<code>sum</code>不为<code>2</code>的倍数直接返回<code>false</code>。假如为<code>2</code>的倍数，就计算这些数能否选取一些数相加和为<code>sum / 2</code>。</p>
<p>动态规划：<code>dp[i][j]</code>表示选取<code>nums</code>前<code>[0, i]</code>（每个数只选一次）能否组成和为<code>j</code>的子集。</p>
<p>再考虑空间优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; sum / <span class="number">2</span>) &#123;</span><br><span class="line">            dp[nums[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sum / <span class="number">2</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dp[j] &amp;&amp; j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[j] = dp[j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == sum / <span class="number">2</span> &amp;&amp; dp[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】437-路径总和-III"><a href="#【M】437-路径总和-III" class="headerlink" title="【M】437. 路径总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">【M】437. 路径总和 III</a></h4><blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>
<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
</blockquote>
<p>大致上知道要用前缀和保存路径出现的次数，有几个小细节需要注意：</p>
<ol>
<li><p><code>map</code>初始化的时候往里加入<code>(0, 1)</code></p>
</li>
<li><p>进入<code>dfs</code>，在<code>path</code>加上当前节点的值后，先在<code>map</code>里找有没有值为<code>(path - target)</code>的键，再把当前路径加到<code>map</code>中（<strong>注意这个先后顺序</strong>，我就是在这里翻车的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count += map.getOrDefault(path - targetSum, <span class="number">0</span>);</span><br><span class="line">map.put(path, map.getOrDefault(path, <span class="number">0</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>为什么要遵循这样的顺序？因为map中存放的是<strong>前缀和</strong>，key保存的是就是从根节点到路径上前面这些节点的可能的和。假如<code>map</code>中含有<code>key = 8</code>，说明在这条从根节点到当前节点的路径上（不包括当前节点）存在路径为<code>8</code>的值。此时<code>path = 10</code>，<code>targetSum = 2</code>，那么就可以<code>count += map.get(key)</code>了</p>
<p>假如先put再count的话，就不符合前缀和的概念了。先put，就把当前节点算在内了</p>
</li>
</ol>
<p><strong>完整代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> targetSum;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.targetSum = targetSum;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path += root.val;</span><br><span class="line">        count += map.getOrDefault(path - targetSum, <span class="number">0</span>);</span><br><span class="line">        map.put(path, map.getOrDefault(path, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        map.put(path, map.get(path) - <span class="number">1</span>);</span><br><span class="line">        path -= root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】438-找到字符串中所有字母异位词"><a href="#【M】438-找到字符串中所有字母异位词" class="headerlink" title="【M】438. 找到字符串中所有字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">【M】438. 找到字符串中所有字母异位词</a></h4><blockquote>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
</blockquote>
<p>滑动窗口。</p>
<p>先把<code>p</code>的字母频次记录下来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">    pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后设置双指针遍历<code>s</code>字符串</p>
<p>假如<code>right</code>所指向字符的频次比要求的频次高，就一直把<code>left</code>指针右移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = s.charAt(right) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">sCount[index]++;</span><br><span class="line"><span class="keyword">while</span> (sCount[index] &gt; pCount[index]) &#123;</span><br><span class="line">    sCount[s.charAt(left) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    left++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳出循环后再判断长度是不是符合要求</p>
<p><strong>完整代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] sCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span>[] pCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">        pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = s.charAt(right) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        sCount[index]++;</span><br><span class="line">        <span class="keyword">while</span> (sCount[index] &gt; pCount[index]) &#123;</span><br><span class="line">            sCount[s.charAt(left) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> == p.length()) &#123;</span><br><span class="line">            res.add(left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么<code>left</code>一直右移？</p>
</blockquote>
<p>因为此时<code>right</code>所指的字符串的频次太高了，需要剔除掉窗口左侧多余的字符</p>
<h4 id="【E】461-汉明距离"><a href="#【E】461-汉明距离" class="headerlink" title="【E】461. 汉明距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hamming-distance/">【E】461. 汉明距离</a></h4><blockquote>
<p>两个整数之间的 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离</p>
</blockquote>
<p>我想到的做法是对x和y的每一位进行异或然后右移。实际上可以先把x和y异或的结果算出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = x ^ y;</span><br></pre></td></tr></table></figure>

<p>然后对这个值进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">    temp &amp;= (temp - <span class="number">1</span>);</span><br><span class="line">    res++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】494-目标和"><a href="#【M】494-目标和" class="headerlink" title="【M】494. 目标和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">【M】494. 目标和</a></h4><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
</blockquote>
<p>想到了要先算数组和sum，然后所有前面为减号的数据的和为<code>decr</code>，那么所有前面为加号的数据和为<code>sum - decr</code>，所以<code>sum - decr - decr = target</code>，<code>decr * 2 = sum - target</code>，如果<code>sum - target</code>不是<code>2</code>的倍数直接返回<code>0</code></p>
<p>问题转化为：从<code>nums</code>中选取若干数，求出和为<code>(sum - target) / 2</code>的方法个数</p>
<p>后面就出现了问题，没看清题目的条件（<code>nums[i] &gt;= 0</code>），导致新建<code>dp</code>数组的时候还考虑了负数。<code>dp[i][j]</code>表示取数组<code>[0, i]</code>中的元素，和为<code>j</code>的方法数</p>
<p>此外考虑空间优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">      sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((sum - target) % <span class="number">2</span> == <span class="number">1</span> || (sum - target) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> decr = (sum - target) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[decr + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; decr + <span class="number">1</span>) &#123;</span><br><span class="line">      dp[nums[<span class="number">0</span>]] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = decr; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">          dp[j] += dp[j - nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[decr];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】538-把二叉搜索树转换为累加树"><a href="#【M】538-把二叉搜索树转换为累加树" class="headerlink" title="【M】538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">【M】538. 把二叉搜索树转换为累加树</a></h4><blockquote>
<p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
</blockquote>
<p>递归的做法很容易想到，迭代不熟。参考二叉树中序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    TreeNode res = root;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.poll();</span><br><span class="line">        root.val += pre;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【E】543-二叉树的直径"><a href="#【E】543-二叉树的直径" class="headerlink" title="【E】543. 二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">【E】543. 二叉树的直径</a></h4><blockquote>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
</blockquote>
<p>我的想法是先<code>dfs</code>到每个节点然后分别计算每个节点的直径求出最大值。题解里有更简单的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        max = Math.max(max, left + right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【E】617-合并二叉树"><a href="#【E】617-合并二叉树" class="headerlink" title="【E】617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">【E】617. 合并二叉树</a></h4><blockquote>
<p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>
</blockquote>
<p>首先要清楚可以分为递归和迭代两种做法</p>
<p><strong>递归</strong></p>
<p>我想的递归是这样的：建立一颗新的树进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeNode newRoot = <span class="keyword">new</span> TreeNode(root1.val + root2.val);</span><br><span class="line">newRoot.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">newRoot.right = mergeTrees(root1.right, root2.right);</span><br></pre></td></tr></table></figure>

<p>其实有更简单的递归，直接在某一颗树上加值就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root1.val += root2.val;</span><br><span class="line">root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">root1.right = mergeTrees(root1.right, root2.right);</span><br></pre></td></tr></table></figure>

<p><strong>迭代</strong></p>
<p>迭代也是一样，在某棵树上进行操作。我的想法还是复杂了，想新建一棵树</p>
<p>首先把root1和root2放入队列。然后进入循环：</p>
<p><code>poll</code>两个节点为<code>cur1</code>和<code>cur2</code>，把两个节点的值相加（因为能放入队列的节点必不为空）。假如cur1和cur2的左节点都不为空，就把两个左节点放进队列；假如cur1的左节点为空，就直接把cur2的左节点挂在cur1上。右节点同理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root1);</span><br><span class="line">    queue.offer(root2);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node1 = queue.poll();</span><br><span class="line">        TreeNode node2 = queue.poll();</span><br><span class="line">        node1.val += node2.val;</span><br><span class="line">        <span class="keyword">if</span> (node1.left != <span class="keyword">null</span> &amp;&amp; node2.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node1.left);</span><br><span class="line">            queue.offer(node2.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node1.left = node2.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1.right != <span class="keyword">null</span> &amp;&amp; node2.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node1.right);</span><br><span class="line">            queue.offer(node2.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node1.right = node2.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hco3o.xyz/2022/03/28/LCOF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hco3o's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/28/LCOF/" itemprop="url">LCOF</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-28T21:05:21+08:00">
                2022-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="【E】剑指-Offer-03-数组中重复的数字"><a href="#【E】剑指-Offer-03-数组中重复的数字" class="headerlink" title="【E】剑指 Offer 03. 数组中重复的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">【E】剑指 Offer 03. 数组中重复的数字</a></h4><blockquote>
<p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 <code>nums</code> 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
</blockquote>
<p>因为长度为<code>n</code>，数字都在<code>[0, n - 1]</code>范围内，可以借助索引<code>index</code>和值<code>nums[index]</code>的对应关系来判断</p>
<p><strong>流程</strong></p>
<ol>
<li>假如<code>nums[index] == index</code>，说明数字已经在索引位置了，跳过</li>
<li>假如<code>nums[nums[index]] == nums[index]</code>，说明索引<code>nums[index]</code>和索引<code>i</code>的元素值都为<code>nums[i]</code>，返回这个<code>nums[i]</code></li>
<li>都不符合，交换索引<code>i</code>和<code>nums[i]</code>的元素，把该数字放到索引位置</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/1618146573-bOieFQ-Picture0.png" alt="Picture0.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] == index) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[nums[index]] == nums[index]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, index, nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【E】剑指-Offer-06-从尾到头打印链表"><a href="#【E】剑指-Offer-06-从尾到头打印链表" class="headerlink" title="【E】剑指 Offer 06. 从尾到头打印链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">【E】剑指 Offer 06. 从尾到头打印链表</a></h4><blockquote>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
</blockquote>
<p>使用栈的做法很简单，递归不会</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recur(head);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recur(head.next);</span><br><span class="line">        list.add(head.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【E】剑指-Offer-15-二进制中1的个数"><a href="#【E】剑指-Offer-15-二进制中1的个数" class="headerlink" title="【E】剑指 Offer 15. 二进制中1的个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">【E】剑指 Offer 15. 二进制中1的个数</a></h4><blockquote>
<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p>
<p><strong>提示：</strong></p>
<ul>
<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
<li>在 Java 中，编译器使用 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284">二进制补码</a> 记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li>
</ul>
</blockquote>
<p>不多说，上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】剑指-Offer-14-II-剪绳子-II"><a href="#【M】剑指-Offer-14-II-剪绳子-II" class="headerlink" title="【M】剑指 Offer 14- II. 剪绳子 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">【M】剑指 Offer 14- II. 剪绳子 II</a></h4><blockquote>
<p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
</blockquote>
<p>注意两点：long转int、求快速幂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> mask = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">3</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            res = (res * mask) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mask = (mask * mask) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (res * <span class="number">3</span> % <span class="number">1000000007</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ((res * <span class="number">4</span>) % <span class="number">1000000007</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ((res * <span class="number">6</span>) % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】剑指-Offer-46-把数字翻译成字符串"><a href="#【M】剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="【M】剑指 Offer 46. 把数字翻译成字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">【M】剑指 Offer 46. 把数字翻译成字符串</a></h4><blockquote>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
</blockquote>
<p>想到了要从右往左用动态规划，有些细节处理的不到位</p>
<p>每次进入循环，先把<code>num / 10</code>，然后<code>x = num % 10</code>，因为之前y中保留了x的后一位，要判断这个数和后面的数加起来的值就直接<code>temp = (x * 10) + y</code>，如果temp在<code>[10, 25]</code>范围里，<code>count = left + right</code>，否则<code>count = left</code>。最后把<code>x</code>的值赋给<code>y</code>，进入下一次循环</p>
<p>核心代码就是<code>temp</code>怎么求，因为假如是226，就会有<code>2 + 26</code>和<code>22 + 6</code>两种结果。怎么得到<code>22</code>这个值就很重要</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x = num % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> y = num % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">        x = num % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = x * <span class="number">10</span> + y;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= <span class="number">10</span> &amp;&amp; temp &lt; <span class="number">26</span>) &#123;</span><br><span class="line">            count = left + right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count = left;</span><br><span class="line">        &#125;</span><br><span class="line">        right = left;</span><br><span class="line">        left = count;</span><br><span class="line">        y = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【E】剑指-Offer-62-圆圈中最后剩下的数字"><a href="#【E】剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="【E】剑指 Offer 62. 圆圈中最后剩下的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">【E】剑指 Offer 62. 圆圈中最后剩下的数字</a></h4><blockquote>
<p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
</blockquote>
<p>正向模拟一遍：</p>
<p><img src="https://pic.leetcode-cn.com/d7768194055df1c3d3f6b503468704606134231de62b4ea4b9bdeda7c58232f4-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF1.png" alt="约瑟夫环1.png"></p>
<p>想要知道<code>N = 8</code>时的索引，可以从<code>N = 1</code>的时候往前倒推。意思是只关心<strong>G元素</strong>的坐标变化</p>
<hr>
<ul>
<li><strong>以<code>N = 5</code>向<code>N = 6</code>倒推为例：</strong></li>
</ul>
<p>从**<code>[B, D, E, G, H] ===&gt; [G, H, A, B, D, E]</code>**。此时<code>index = 3</code>，倒推过后<code>index = 0</code></p>
<p><code>N = 6</code>正向到<code>N = 5</code>的过程中，删除了元素<code>&#39;A&#39;</code>，然后把<code>&#39;A&#39;</code>后面的元素<code>&#39;B&#39;</code>放到了首位。相当于左移了<code>m</code>位</p>
<p>在反推的过程中，就需要把数组整体向右移<code>m</code>位，并且要加上在上一个步骤中被移除的元素（这里是<code>&#39;A&#39;</code>）。但是移动之后右侧会溢出，再把溢出的部分放到左边</p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220314182942210.png" alt="image-20220314182942210"></p>
<p>具体到<strong>索引</strong>的变换，就是反推前<code>index = 3</code>，右移<code>m</code>位（<code>3</code>位）后<code>index = 6</code>，此时超出了<code>N = 6</code>时的最大索引<code>5</code>，于是<code>index</code>放到了第一位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = (index + m) % i;</span><br></pre></td></tr></table></figure>

<p>这里的<code>i</code>就表示倒推后数组的长度（从<code>2</code>到<code>n</code>）</p>
<p><strong>完整代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        index = (index + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【M】剑指-Offer-64-求1-2-…-n"><a href="#【M】剑指-Offer-64-求1-2-…-n" class="headerlink" title="【M】剑指 Offer 64. 求1+2+…+n"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">【M】剑指 Offer 64. 求1+2+…+n</a></h4><blockquote>
<p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【E】剑指-Offer-65-不用加减乘除做加法"><a href="#【E】剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="【E】剑指 Offer 65. 不用加减乘除做加法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">【E】剑指 Offer 65. 不用加减乘除做加法</a></h4><blockquote>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
</blockquote>
<p>把a做为<strong>不考虑进位的和</strong>，b做为<strong>只计算进位的和</strong></p>
<p><code>a = (a ^ b)</code>、<code>b = (a &amp; b) &lt;&lt; 1</code></p>
<ol>
<li><p>递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> add(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = (a ^ b);</span><br><span class="line">        b = (temp &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="【E】剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#【E】剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="【E】剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">【E】剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hco3o.xyz/2022/03/28/select-poll-epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hco3o's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/28/select-poll-epoll/" itemprop="url">select/poll/epoll</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-28T20:35:09+08:00">
                2022-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><ul>
<li><p>已连接的Socket放到一个<strong>文件描述符集合</strong></p>
</li>
<li><p>调用select函数把集合拷贝到内核，让内核判断是否有网络事件</p>
<blockquote>
<p>检查的方式就是遍历整个集合</p>
</blockquote>
</li>
<li><p>假如有事件产生，就把Socket标记为可读或可写</p>
</li>
<li><p>再把整个集合拷贝回用户态</p>
</li>
<li><p>用户态遍历找到可读或可写的Socket进行处理</p>
</li>
</ul>
<p><strong>两次遍历文件描述符集合、两次拷贝文件描述符集合</strong></p>
<p>select使用固定长度BitsMap表示文件描述符集合</p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll使用链表组织文件描述符</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><ul>
<li><p>内核中使用红黑树跟踪进程所有待检测的文件描述字，把需要监控的socket通过epoll_ctl函数加入到内核的红黑树</p>
<blockquote>
<p>增删改查时间复杂度O(logn)，无需传入整个集合，只传待检测的socket</p>
</blockquote>
</li>
<li><p>内核维护链表记录就绪事件。某个socket有事件发生时，通过回调函数，内核会把它加到就绪事件列表中。用户调用epoll_wait函数，只返回有事件发生的文件描述符的个数</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220328204803760.png" alt="image-20220328204803760"></p>
<h2 id="边缘触发"><a href="#边缘触发" class="headerlink" title="边缘触发"></a>边缘触发</h2><ul>
<li><strong>边缘触发</strong>：被监控socket描述符有可读事件，服务器<strong>只会从<code>epoll_wait</code>中苏醒一次</strong>。即便进程没有调用read从内核读取数据也只苏醒一次。所以要保证一次性把内核缓存中的数据读完</li>
</ul>
<p>收到通知后尽可能读写数据</p>
<p>所以要循环从文件描述符读写，如果是阻塞没有数据可读写时，进程会阻塞在读写函数那里，程序没办法继续执行。所以<strong>边缘触发通常搭配非阻塞I/O</strong></p>
<h2 id="水平触发"><a href="#水平触发" class="headerlink" title="水平触发"></a>水平触发</h2><ul>
<li><strong>水平触发</strong>：被监控socket描述符有可读事件，<strong>服务器不断从<code>epoll_wait</code>苏醒</strong>，直到内核缓存中数据被read完</li>
</ul>
<p>收到通知没必要一次执行尽可能多的读写操作</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>最基础的TCPsocket是阻塞IO模型，只能一对一通信</li>
<li>传统方式使用多进程/多线程模型。每来一个客户端连接就分配一个进程或线程，然后读写都在这个进程或线程里。瓶颈是进程线程调度、上下文切换和占用内存</li>
<li>select/poll/epoll</li>
<li>边缘触发效率高，因为减少了<code>epoll_wait</code>的调用次数<ul>
<li>select/poll只有水平触发</li>
<li>epoll默认水平触发，可以设置为边缘触发</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hco3o.xyz/2022/03/28/%E9%9B%B6%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hco3o's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/28/%E9%9B%B6%E6%8B%B7%E8%B4%9D/" itemprop="url">零拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-28T18:33:11+08:00">
                2022-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a><code>DMA</code>技术</h2><h3 id="不使用DMA的I-O"><a href="#不使用DMA的I-O" class="headerlink" title="不使用DMA的I/O"></a>不使用<code>DMA</code>的<code>I/O</code></h3><ol>
<li>CPU发指令给磁盘控制器</li>
<li>磁盘控制器准备数据，把数据放到控制器的内部缓存，产生中断</li>
<li>CPU收到中断，停下手中的工作把磁盘缓冲区数据一个字节一个字节读入自己的寄存器，然后写入内存</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220328160852244.png" alt="image-20220328160852244"></p>
<h3 id="使用DMA的I-O"><a href="#使用DMA的I-O" class="headerlink" title="使用DMA的I/O"></a>使用<code>DMA</code>的<code>I/O</code></h3><ol>
<li>用户进程调用read方法，向操作系统发出I/O请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态</li>
<li>操作系统收到请求后，进一步将I/O请求发送DMA，然后让CPU执行其他任务</li>
<li>DMA进─步将IVO请求发送给磁盘</li>
<li>磁盘收到DMA的I/O请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA发起中断信号，告知自己缓冲区已满</li>
<li>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用CPU，CPU 可以执行其他任务</li>
<li>当DMA读取了足够多的数据，就会发送中断信号给CPU</li>
<li>CPU 收到 DMA的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220328160901597.png" alt="image-20220328160901597"></p>
<h2 id="服务端文件传输的几种方式"><a href="#服务端文件传输的几种方式" class="headerlink" title="服务端文件传输的几种方式"></a>服务端文件传输的几种方式</h2><h3 id="read-write"><a href="#read-write" class="headerlink" title="read + write"></a><code>read + write</code></h3><ol>
<li>磁盘数据拷贝到内核态缓存（DMA）</li>
<li>内核态缓存拷贝到用户缓存（CPU），需要上下文切换</li>
<li>用户缓存拷贝到内核socket缓存（CPU），需要上下文切换</li>
<li>内核socket缓存拷贝到网卡缓存（DMA）</li>
</ol>
<p><strong>四次数据拷贝，四次用户态与内核态的上下文切换</strong></p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220328155851817.png" alt="image-20220328155851817"></p>
<h3 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a><code>mmap + write</code></h3><ol>
<li>应用程序调用<code>mmap()</code>，磁盘数据拷贝到内核态缓存（DMA）。应用程序与内核共享这块缓存区域</li>
<li>应用程序调用write()，操作系统把内核态缓存的数据直接拷贝到socket缓存（CPU）。这一切发生在内核态</li>
<li>内核socket缓存拷贝到网卡缓存（DMA）</li>
</ol>
<p><strong>三次数据拷贝，四次上下文切换</strong></p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220328155913426.png" alt="image-20220328155913426"></p>
<h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a><code>sendfile</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>目标端文件描述符</li>
<li>源端文件描述符</li>
<li>源端偏移量</li>
<li>复制数据的长度</li>
</ul>
<p>返回值</p>
<ul>
<li>实际复制数据的长度</li>
</ul>
<p><strong>三次数据拷贝，两次上下文切换</strong></p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220328155152759.png" alt="image-20220328155152759"></p>
<h3 id="真正的零拷贝"><a href="#真正的零拷贝" class="headerlink" title="真正的零拷贝"></a>真正的零拷贝</h3><p>网卡支持<code>SG-DMA</code></p>
<ol>
<li>磁盘数据拷贝到内核缓存（DMA）</li>
<li>内核缓存描述符和数据长度传给socket缓存，网卡<code>SG-DMA</code>直接将内核缓存数据拷贝到网卡缓存</li>
</ol>
<p><strong>两次上下文切换，两次数据拷贝（都由DMA完成）</strong></p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220328155726297.png" alt="image-20220328155726297"></p>
<h2 id="内核缓存——PageCache"><a href="#内核缓存——PageCache" class="headerlink" title="内核缓存——PageCache"></a>内核缓存——<code>PageCache</code></h2><blockquote>
<p><code>PageCache</code>缓存最近被访问的数据（减少读取磁盘的次数）</p>
</blockquote>
<p>读磁盘时优先从<code>PageCache</code>里找，如果找不到就从磁盘中读然后缓存到<code>PageCache</code>里</p>
<p>空间不足时淘汰最久未被访问的缓存</p>
<blockquote>
<p>预读（减少旋转磁头的影响）</p>
</blockquote>
<p>read每次读32KB，内核把<code>33~64KB</code>的数据也读到<code>PageCache</code>中，后面再读取<code>33~64KB</code>的数据的时候代价会变小</p>
<blockquote>
<p><code>PageCache</code>不适合大文件传输</p>
</blockquote>
<h2 id="大文件传输"><a href="#大文件传输" class="headerlink" title="大文件传输"></a>大文件传输</h2><p>最初read读取文件，进程要阻塞直到磁盘返回数据</p>
<blockquote>
<p>阻塞使用异步<code>I/O</code>解决</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220328162036001.png" alt="image-20220328162036001"></p>
<p>绕开了<code>PageCache</code>，称为直接<code>I/O</code>，如果使用<code>PageCache</code>则为缓存<code>I/O</code></p>
<p>大文件不能使用<code>PageCache</code>，被占用后使得热点小文件无法使用</p>
<blockquote>
<p>高并发使用异步<code>I/O</code> + 直接<code>I/O</code></p>
</blockquote>
<ul>
<li>传输大文件：异步<code>I/O</code> + 直接<code>I/O</code></li>
<li>传输小文件：零拷贝</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hco3o.xyz/2022/03/26/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hco3o's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/26/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url">内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-26T19:32:25+08:00">
                2022-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>操作系统引入虚拟内存，进程持有的虚拟地址会通过CPU芯片中的内存管理单元(MMU)的映射关系，来转换成为物理地址，然后再通过物理地址访问内存 </p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220314195605351.png" alt="image-20220314195605351"></p>
<h1 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h1><p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220320170407734.png" alt="image-20220320170407734"></p>
<blockquote>
<p>缺点</p>
<ul>
<li>内存碎片</li>
<li>内存交换效率低</li>
</ul>
</blockquote>
<h2 id="产生内存碎片"><a href="#产生内存碎片" class="headerlink" title="产生内存碎片"></a>产生内存碎片</h2><p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220320170039924.png" alt="image-20220320170039924"></p>
<h2 id="内存交换效率低"><a href="#内存交换效率低" class="headerlink" title="内存交换效率低"></a>内存交换效率低</h2><p>把音乐的256MB写到硬盘，再写到内存中（紧跟已被占用的512MB）。这样能空出连续的256MB空间。<strong>硬盘访问速度慢</strong></p>
<h1 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h1><p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220320165715643.png" alt="image-20220320165715643"></p>
<blockquote>
<p>缺点：进程多，页表庞大</p>
<p>32位系统，虚拟地址空间4GB（0x00000000 ~ 0xFFFFFFFF，即最大虚拟内存为2<sup>32</sup> Bytes = 4GB），一个页大小4KB，虚拟地址空间需要分成2<sup>20</sup>个页。页表里每行需要4字节，4GB映射需要4MB内存存储页表</p>
<p>100个进程，需要400MB</p>
</blockquote>
<h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>把2<sup>20</sup>个页表项再分页，把一个页表分为2<sup>10</sup>个页表（二级页表），每个二级页表中包含2<sup>10</sup>个<strong>页表项</strong>。这样就一共是2<sup>20</sup>个页表项</p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220320172545471.png" alt="image-20220320172545471"></p>
<blockquote>
<p>分二级表，映射地址空间需要4KB（一级页表） + 4MB（二级页表）内存，占用空间更大了？</p>
</blockquote>
<p>大多数程序使用到的空间远未达到4GB，部分对应的页表项是空的。对于已经分配的页表项，如果存在一定时间未访问的页表，在物理内存紧张的情况下会把页面换出到硬盘。</p>
<p>使用二级分页后，<strong>假如一级页表项没用到就不用创建二级页表</strong>，相当于节省了4MB（二级页表的大小）空间。</p>
<blockquote>
<p>64位系统使用四级目录</p>
</blockquote>
<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p>多级页表多了转换步骤，有时间开销</p>
<p><strong>把最常访问的页表存储到访问速度更快的硬件——TLB</strong></p>
<p>CPU封装了内存管理单元MMU，来完成地址转换和TLB的访问和交互。CPU寻址时先查TLB再去查页表</p>
<h1 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h1><ul>
<li>把程序划分为多个有意义的段（内存分段）</li>
<li>把每个段划分为多个页（内存分页）</li>
</ul>
<blockquote>
<p>地址由<strong>段号、段内页号、页内偏移</strong>组成</p>
</blockquote>
<p>需要经过三次内存访问</p>
<ul>
<li>访问段表得到页表起始地址</li>
<li>访问页表得到物理页号</li>
<li>把物理页号和页内偏移组合得到物理地址</li>
</ul>
<h1 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h1><ul>
<li>逻辑地址：程序所使用的地址，通常是未被段式内存管理映射的地址</li>
<li>虚拟地址：通过段式内存管理映射的地址</li>
</ul>
<p><strong>Linux采用页式内存管理，但同时不可避免地设计了段机制</strong></p>
<p>Linux系统每个段都是从0地址开始的整个4GB虚拟空间（32位环境），也就是说所有段的起始地址是一样的。Linux所面对的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了CPU中的逻辑地址概念，段只被用于访问控制和内存保护。</p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220320190242757.png" alt="image-20220320190242757"></p>
<blockquote>
<p>内核空间和用户空间的区别</p>
</blockquote>
<ul>
<li>进程在用户态只能访问用户空间内存</li>
<li>进入内核态才可以访问内核空间内存</li>
</ul>
<p>每个进程有独立的虚拟内存，<strong>每个虚拟内存中的内核地址都关联相同的物理内存</strong>（方便进程切换到内核态的时候访问内核空间）</p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220320190555739.png" alt="image-20220320190555739"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hco3o.xyz/2022/03/26/%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hco3o's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/26/%E6%89%8B%E5%86%99RPC%E6%A1%86%E6%9E%B6/" itemprop="url">手写RPC框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-26T18:52:11+08:00">
                2022-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="课程大纲-amp-理论篇概述"><a href="#课程大纲-amp-理论篇概述" class="headerlink" title="课程大纲&amp;理论篇概述"></a>课程大纲&amp;理论篇概述</h2><ul>
<li><p>理论篇（RPC核心原理、相关技术介绍）</p>
</li>
<li><p>实战篇（<code>gk-rpc</code>代码实现、使用案例）</p>
</li>
<li><p>总结篇 </p>
</li>
</ul>
<h2 id="概念讲解"><a href="#概念讲解" class="headerlink" title="概念讲解"></a>概念讲解</h2><p><strong>RPC</strong>： Remote Procedure Call，即远程过程调用</p>
<ul>
<li>procedure：一段可执行的代码（没有返回值的方法）</li>
<li>call：调用了进程的方法</li>
</ul>
<p>是分布式系统常见的一种通信方法，从<strong>跨进程</strong>到跨物理机已经有几十年历史</p>
<p><strong>跨进程交互方式</strong>：RESTful、WebService、HTTP、基于DB做数据交换、基于MQ做数据交换以及RPC</p>
<h2 id="图解交互形式-现有框架对比"><a href="#图解交互形式-现有框架对比" class="headerlink" title="图解交互形式-现有框架对比"></a>图解交互形式-现有框架对比</h2><p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220124105403753.png" alt="image-20220124105403753"></p>
<p>两个系统异步执行，相互不影响。系统A放到数据存储系统，B获取到数据，拿到后就可以进行下一步的动作</p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220124105506615.png" alt="image-20220124105506615"></p>
<p>同步执行，客户端会影响到服务端。对响应的速度要求高</p>
<p>客户端会一直等待服务端的返回</p>
<hr>
<p>在RPC中：</p>
<ul>
<li>Server： Provider、服务提供者</li>
<li>Client： Consumer、服务消费者</li>
<li>Stub：存根、服务描述（理解为Java接口）</li>
</ul>
<p><strong>RPC的优势：可以像调用本地方法那样调用远程方法</strong></p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220124111708964.png" alt="image-20220124111708964"></p>
<ul>
<li>跨语言：允许server端和client端使用不同的语言</li>
<li>服务定义：如何描述服务（Java接口就是存根）</li>
<li>服务治理：RPC调用加上对服务的综合管理（加上注册中心，权限控制等）</li>
</ul>
<p><code>dubbo</code>不仅是RPC框架，也是服务治理框架</p>
<h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220124112258893.png" alt="image-20220124112258893"></p>
<ol start="0">
<li>server把需要暴露的服务和地址信息注册到注册中心</li>
<li>client订阅注册中心，从注册中心关注需要的服务在哪里</li>
<li>如果server地址发生改变，需要重新注册到registry，然后registry通知client</li>
<li>client已经有了server的地址以及暴露的服务的信息，就可以进行调用了</li>
</ol>
<p>注册中心不是必要的组件，client可以把服务端的信息写死，直接调用server</p>
<p>call是RPC最关键的一步</p>
<p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220124113624611.png" alt="image-20220124113624611"></p>
<ol>
<li>client要调用接口里的方法，也就是<strong>存根</strong>里的方法</li>
<li>首先要把传输的对象转化为二进制，这个过程叫做序列化</li>
<li>方法的实现在远程，所以要通过网络传输才能达到调用（socket与server建立连接，传输数据）。</li>
<li>server收到数据后要做的第一步进行反序列化成对象。在对象中包含了客户端要调用的服务端的信息（哪个接口、接口的哪个方法、方法的参数类型、返回值类型、实参）</li>
<li>server找到具体实现类的对象（为了性能考虑，做成单例对象），找到对象后通过反射调用方法</li>
<li>调用完成后得到结果</li>
<li>把结果序列化成二进制</li>
<li>通过网络传输响应给client</li>
<li>client接收到数据后反序列化为对象</li>
<li>得到结果</li>
</ol>
<blockquote>
<p>RPC需要：</p>
</blockquote>
<ul>
<li>网络模块</li>
<li>序列化模块（对象与二进制互转）</li>
<li>client端（如何通过调用接口调用到远程方法？内部有存根的代理对象，网络交互、序列化操作都是由代理对象完成）</li>
<li>server端（里面有服务管理组件，完成服务查找、服务反射调用）</li>
</ul>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li>基础知识：JavaCore、Maven（多模块管理）、反射</li>
<li>动态代理（生成client存根实际调用对象）：Java动态代理（只能代理接口）</li>
<li>序列化（Java对象与二进制数据互转）：Fastjson</li>
<li>网络通信（传输序列化后的二进制数据，走HTTP）：jetty（服务端）、JDK自带的URLConnection（客户端）。使用长连接。</li>
</ul>
<h1 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>第一步：创建工程、（server与client）指定协议、通用工具方法</p>
<p>第二步：实现序列化模块</p>
<p>第三步：实现网络模块（根据RPC通信场景，对网络通信做一层抽象）</p>
<p>第四步：实现Server模块（暴露服务，对服务做管理）</p>
<p>第五步：实现Client模块（用动态代理，代理对象内部通过网络通信与server进行交互）</p>
<p>第六步：<code>gk-rpc</code>使用案例</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://raw.githubusercontent.com/hco3o/cloudimg/master/image-20220124122026361.png" alt="image-20220124122026361"></p>
<ol>
<li><p>协议模块：描述server与client之间的通信协议</p>
<p>两个核心的类：</p>
<ul>
<li><code>Request</code>（需要请求<code>server</code>的哪个服务，请求服务时携带的参数）</li>
<li><code>Response</code>（<code>server</code>响应给<code>client</code>的返回信息：是否成功，返回值）</li>
<li><code>ServiceDescriptor</code>：服务的描述信息</li>
</ul>
</li>
<li><p>序列化模块：<code>Encoder</code>（对象转二进制）、<code>Decoder</code>（二进制转对象），都是基于<code>JSON</code>实现</p>
</li>
<li><p>网络模块：<code>server</code>端和<code>client</code>端，基于<code>HTTP</code>实现</p>
</li>
<li><p><code>server</code>模块</p>
<ul>
<li><code>ServiceManager</code>维护<code>RpcServer</code>需要暴露的服务，需要暴露的服务注册到这里</li>
<li><code>ServiceInstance</code>暴露出去的这个服务的具体对象、具体实现</li>
</ul>
</li>
<li><p><code>client</code>模块：核心是<code>RpcClient</code></p>
<ul>
<li><code>RemoteInvoker</code>会把<code>client</code>请求通过<code>RemoteInvoker</code>和<code>server</code>进行交互，交互的信息通过<code>Request</code>和<code>Response</code>进行封装</li>
<li><code>TransportSelector</code>：因为一个<code>client</code>可能会连接不同的<code>server</code>，把网络连接做了一个<code>Selector</code>抽象。生成一个基于随机的选择器</li>
</ul>
</li>
</ol>
<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><ul>
<li>common: 公用工具方法</li>
<li>proto: server与client之间的协议</li>
<li>codec: 序列化</li>
<li>transport: 网络通信模块</li>
<li>server</li>
<li>client</li>
</ul>
<h2 id="各模块"><a href="#各模块" class="headerlink" title="各模块"></a>各模块</h2><h3 id="proto协议"><a href="#proto协议" class="headerlink" title="proto协议"></a><code>proto</code>协议</h3><h4 id="peer"><a href="#peer" class="headerlink" title="peer"></a><code>peer</code></h4><p>表示网络通信的端点类</p>
<p>网络的地址：host远程主机地址，port端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Peer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ServiceDescriptor"><a href="#ServiceDescriptor" class="headerlink" title="ServiceDescriptor"></a><code>ServiceDescriptor</code></h4><p>表示服务的类</p>
<p>描述一个服务需要四个属性：</p>
<ul>
<li>类名：<code>clazz</code></li>
<li>方法名：<code>method</code></li>
<li>返回类型：<code>returnType</code></li>
<li>参数：<code>parameterTypes</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceDescriptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String clazz;</span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line">    <span class="keyword">private</span> String returnType;</span><br><span class="line">    <span class="keyword">private</span> String[] parameterTypes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在后面<code>ServiceManager</code>管理类中，当注册服务到map中的时候，需要根据<strong>接口</strong>和<strong>当前的方法</strong>作为参数生成一个<code>ServiceDescriptor</code>做为key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServiceDescriptor <span class="title">from</span><span class="params">(Class clazz, Method method)</span> </span>&#123;</span><br><span class="line">    ServiceDescriptor serviceDescriptor = <span class="keyword">new</span> ServiceDescriptor();</span><br><span class="line">    <span class="comment">// 设置类名</span></span><br><span class="line">    serviceDescriptor.setClazz(clazz.getName());</span><br><span class="line">    <span class="comment">// 设置方法名</span></span><br><span class="line">    serviceDescriptor.setMethod(method.getName());</span><br><span class="line">    <span class="comment">// 设置返回类型</span></span><br><span class="line">    serviceDescriptor.setReturnType(method.getReturnType().getName());</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    Class[] parameterClasses = method.getParameterTypes();</span><br><span class="line">    String[] parameterTypes = <span class="keyword">new</span> String[parameterClasses.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterClasses.length; i++) &#123;</span><br><span class="line">        parameterTypes[i] = parameterClasses[i].getName();</span><br><span class="line">    &#125;</span><br><span class="line">    serviceDescriptor.setParameterTypes(parameterTypes);</span><br><span class="line">    <span class="keyword">return</span> serviceDescriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断map中的<code>ServiceDescriptor</code>和我要get的<code>ServiceDescriptor</code>是不是同一个。需重写<code>equals</code>和<code>hashCode</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toString().hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span> || getClass() != obj.getClass()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两者类型一定一样，强转类型</span></span><br><span class="line">    ServiceDescriptor that = (ServiceDescriptor) obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toString().equals(that.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a><code>Request</code></h4><p>表示一个请求</p>
<p>两个属性：</p>
<ul>
<li>要请求的服务（用<code>ServiceDescriptor</code>描述）</li>
<li>传入的参数<code>parameters</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceDescriptor service;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a><code>Response</code></h4><p>表示RPC的返回</p>
<ul>
<li>服务返回编码。code = 0表示调用成功（默认值），非零表示失败</li>
<li>失败原因（默认OK）</li>
<li>返回的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String message = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="common工具类"><a href="#common工具类" class="headerlink" title="common工具类"></a><code>common</code>工具类</h3><p>反射工具类</p>
<ol>
<li><p>根据class创建对象（使用泛型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用无参构造</span></span><br><span class="line">        <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取某个类的所用public方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Method[] getPublicMethods(Class clazz) &#123;</span><br><span class="line">    <span class="comment">// 当前类所有的方法</span></span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    List&lt;Method&gt; publicMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 只需要public修饰的方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">            publicMethods.add(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> publicMethods.toArray(<span class="keyword">new</span> Method[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用指定对象的指定方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">invoke</span><span class="params">(Object obj, Method method, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(obj, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="codec序列化"><a href="#codec序列化" class="headerlink" title="codec序列化"></a><code>codec</code>序列化</h3><h4 id="Encoder序列化接口"><a href="#Encoder序列化接口" class="headerlink" title="Encoder序列化接口"></a><code>Encoder</code>序列化接口</h4><p>把对象转为byte数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Encoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] encode(Object obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Decoder反序列化接口"><a href="#Decoder反序列化接口" class="headerlink" title="Decoder反序列化接口"></a><code>Decoder</code>反序列化接口</h4><p>把二进制数组转成对象（加泛型，省去强制转换）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Decoder</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">decode</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;T&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JSONEncoder实现序列化"><a href="#JSONEncoder实现序列化" class="headerlink" title="JSONEncoder实现序列化"></a><code>JSONEncoder</code>实现序列化</h4><p>基于JSON的序列化实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONEncoder</span> <span class="keyword">implements</span> <span class="title">Encoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encode(Object obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONBytes(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JSONDecoder实现反序列化"><a href="#JSONDecoder实现反序列化" class="headerlink" title="JSONDecoder实现反序列化"></a><code>JSONDecoder</code>实现反序列化</h4><p>基于JSON的反序列化实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONDecoder</span> <span class="keyword">implements</span> <span class="title">Decoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">decode</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(bytes, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="transport网络通信"><a href="#transport网络通信" class="headerlink" title="transport网络通信"></a><code>transport</code>网络通信</h3><p>导入依赖</p>
<ul>
<li><code>commons-io</code></li>
<li><code>jetty</code></li>
<li>协议模块<code>proto</code></li>
</ul>
<h4 id="TransportClient接口"><a href="#TransportClient接口" class="headerlink" title="TransportClient接口"></a><code>TransportClient</code>接口</h4><p>客户端的协议</p>
<p>要做的事：</p>
<ol>
<li>创建连接</li>
<li>发送数据，等待响应</li>
<li>关闭连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransportClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(Peer peer)</span></span>;</span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="function">InputStream <span class="title">write</span><span class="params">(InputStream data)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TransportServer接口"><a href="#TransportServer接口" class="headerlink" title="TransportServer接口"></a><code>TransportServer</code>接口</h4><p>服务端的协议</p>
<p>要做的事：</p>
<ol>
<li>启动，监听端口</li>
<li>等待网络客户端的请求，接收请求</li>
<li>关闭监听</li>
</ol>
<blockquote>
<p><code>RequestHandler</code>什么时候传给<code>Server</code>？</p>
<p>初始化的时候</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransportServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 把byte数据流抽象为Handler，所以还需要一个RequestHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> port, RequestHandler handler)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RequestHandler接口"><a href="#RequestHandler接口" class="headerlink" title="RequestHandler接口"></a><code>RequestHandler</code>接口</h4><p>处理网络请求</p>
<ul>
<li>receive：输入</li>
<li>toResp：输出数据的通道</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRequest</span><span class="params">(InputStream receive, OutputStream toResp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HttpTransportClient实现client"><a href="#HttpTransportClient实现client" class="headerlink" title="HttpTransportClient实现client"></a><code>HttpTransportClient</code>实现<code>client</code></h4><p>设置全局变量URL</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String url;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>connect</code>方法</p>
<p>拼接URL</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Peer peer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.url = <span class="string">&quot;http://&quot;</span> + peer.getHost() + <span class="string">&quot;:&quot;</span> + peer.getPort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>write</code>方法</p>
<p>用JDK自带的<code>HttpURLConnection</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">write</span><span class="params">(InputStream data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HttpURLConnection httpConnection = (HttpURLConnection) <span class="keyword">new</span> URL(url).openConnection();</span><br><span class="line">        <span class="comment">// 设置这个连接需要读写数据</span></span><br><span class="line">        httpConnection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">        httpConnection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 其它的初始化</span></span><br><span class="line">        httpConnection.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">        httpConnection.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启连接</span></span><br><span class="line">        httpConnection.connect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把data数据发送给server</span></span><br><span class="line">        <span class="comment">// 使用commons-io包</span></span><br><span class="line">        IOUtils.copy(data, httpConnection.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> resultCode = httpConnection.getResponseCode();</span><br><span class="line">        <span class="keyword">if</span> (resultCode == HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">            <span class="comment">// 代码为200</span></span><br><span class="line">            <span class="comment">// 拿到输出并返回</span></span><br><span class="line">            <span class="keyword">return</span> httpConnection.getInputStream();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> httpConnection.getErrorStream();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>close</code>方法</p>
<p>基于短连接，不需要关闭</p>
</li>
</ol>
<h4 id="HttpTransportServer实现server"><a href="#HttpTransportServer实现server" class="headerlink" title="HttpTransportServer实现server"></a><code>HttpTransportServer</code>实现<code>server</code></h4><p>server基于jetty</p>
<p>设置全局变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RequestHandler handler;</span><br><span class="line"><span class="keyword">private</span> Server server;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>init</code>初始化</p>
<p>因为是使用servlet接受请求，需要<code>ServletContextHandler</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> port, RequestHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    <span class="keyword">this</span>.server = <span class="keyword">new</span> Server(port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// servlet接收请求</span></span><br><span class="line">    ServletContextHandler ctx = <span class="keyword">new</span> ServletContextHandler();</span><br><span class="line">    <span class="comment">// 把server的handler设置为ServletContextHandler</span></span><br><span class="line">    server.setHandler(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// holder: jetty处理网络请求的一个抽象</span></span><br><span class="line">    ServletHolder holder = <span class="keyword">new</span> ServletHolder(<span class="keyword">new</span> RequestServlet());</span><br><span class="line">    <span class="comment">// /*: 处理所有的路径</span></span><br><span class="line">    ctx.addServlet(holder, <span class="string">&quot;/*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>start</code></p>
<p>jetty的server启动，start使用线程监听，会立马返回。加join可以让他一直等着server停止关闭</p>
<p>假如server不能启动成功，直接把异常打印（基于slf4j）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        server.start();</span><br><span class="line">        server.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>stop</code></p>
<p>直接关闭server，也是打印异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        server.stop();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>内部类<code>RequestServlet</code></p>
<p>自己创建的<code>Servlet</code>，处理POST请求，实例对象做为<code>ServletHolder</code>的一个参数传进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要处理post请求，重写一下doPost方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;client connected!&quot;</span>);</span><br><span class="line">        <span class="comment">// 拿到client发来的数据</span></span><br><span class="line">        ServletInputStream in = req.getInputStream();</span><br><span class="line">        <span class="comment">// 拿到返回的数据</span></span><br><span class="line">        OutputStream out = resp.getOutputStream();</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handler.onRequest(in, out);</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a><code>server</code></h3><p>引入依赖</p>
<ul>
<li><code>proto</code>协议模块</li>
<li><code>transport</code>网络通信模块</li>
<li><code>codec</code>序列化模块</li>
<li><code>common</code>工具类模块</li>
<li><code>commons-io</code></li>
</ul>
<h4 id="RpcServerConfig配置类"><a href="#RpcServerConfig配置类" class="headerlink" title="RpcServerConfig配置类"></a><code>RpcServerConfig</code>配置类</h4><ul>
<li>使用哪个网络模块</li>
<li>使用哪种序列化反序列化实现</li>
<li>监听哪个端口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends TransportServer&gt; transportClass = HttpTransportServer.class;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends Encoder&gt; encoderClass = JSONEncoder.class;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends Decoder&gt; decoderClass = JSONDecoder.class;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">3000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ServiceInstance服务实例"><a href="#ServiceInstance服务实例" class="headerlink" title="ServiceInstance服务实例"></a><code>ServiceInstance</code>服务实例</h4><p>表示一个具体服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 哪个对象提供服务</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="comment">// 对象的哪个方法暴露成为一个服务</span></span><br><span class="line">    <span class="keyword">private</span> Method method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ServiceManager管理类"><a href="#ServiceManager管理类" class="headerlink" title="ServiceManager管理类"></a><code>ServiceManager</code>管理类</h4><p>管理RPC暴露的服务</p>
<ul>
<li>注册服务（放到Map，k：服务的描述；v：服务的具体实现）</li>
<li>查找服务（根据<code>ServiceDescriptor</code>服务描述查找<code>ServiceInstance</code>实例）</li>
</ul>
<blockquote>
<p>服务描述：</p>
<ul>
<li>类名：<code>clazz</code></li>
<li>方法名：<code>method</code></li>
<li>返回类型：<code>returnType</code></li>
<li>参数：<code>parameterTypes</code></li>
</ul>
<p>服务实例：</p>
<ul>
<li>哪个对象提供服务：target</li>
<li>对象的哪个方法暴露成为一个服务：method</li>
</ul>
</blockquote>
<ol>
<li><p>定义全局变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册的服务放到map里</span></span><br><span class="line"><span class="comment">// k：服务的描述；v：服务的具体实现</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;ServiceDescriptor, ServiceInstance&gt; services;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.services = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注册</p>
<blockquote>
<p>传参</p>
<ul>
<li><p>指定一个接口</p>
</li>
<li><p>服务的具体提供者（单例）</p>
</li>
</ul>
<p>这两个参数是有关系的：bean是interfaceClass接口具体实现的子类的一个对象，使用泛型关联</p>
</blockquote>
<p><code>ServiceDescriptor</code>里需要多写一个方法：把接口和当前遍历到的方法传进去，返回值是一个<code>ServiceDescriptor</code>做为map的key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;T&gt; interfaceClass, T bean)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扫描接口里所有的方法，每个方法和bean绑定成为一个ServiceInstance，放入map</span></span><br><span class="line">    <span class="comment">// 把interface中每一个方法都当成服务注册到ServiceManager</span></span><br><span class="line">    Method[] methods = ReflectionUtils.getPublicMethods(interfaceClass);</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        ServiceInstance serviceInstance = <span class="keyword">new</span> ServiceInstance(bean, method);</span><br><span class="line">        <span class="comment">// 生成key</span></span><br><span class="line">        ServiceDescriptor serviceDescriptor = ServiceDescriptor.from(interfaceClass, method);</span><br><span class="line">        services.put(serviceDescriptor, serviceInstance);</span><br><span class="line">        log.info(<span class="string">&quot;register service: &#123;&#125; &#123;&#125;&quot;</span>, serviceDescriptor.getClazz(), serviceDescriptor.getMethod());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查找</p>
<p>返回一个<code>ServiceInstance</code></p>
<p><code>ServiceDescriptor</code>里需要多写一个方法：判断map中的<code>ServiceDescriptor</code>和我要get的<code>ServiceDescriptor</code>是不是同一个。需重写<code>equals</code>和<code>hashCode</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">lookup</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    ServiceDescriptor serviceDescriptor = request.getService();</span><br><span class="line">    <span class="comment">// get的时候根据ServiceDescriptor的equals方法来判断，需重写一个equals和hashcode方法</span></span><br><span class="line">    <span class="keyword">return</span> services.get(serviceDescriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="ServiceInvoker调用服务"><a href="#ServiceInvoker调用服务" class="headerlink" title="ServiceInvoker调用服务"></a><code>ServiceInvoker</code>调用服务</h4><p>返回类型就是所调用的服务返回的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工具类中的invoke</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Method method, Object... args)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceInvoker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(ServiceInstance serviceInstance, Request request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// request中存放参数</span></span><br><span class="line">        <span class="keyword">return</span> ReflectionUtils.invoke(serviceInstance.getTarget(), serviceInstance.getMethod(), request.getParameters());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RpcServer"><a href="#RpcServer" class="headerlink" title="RpcServer"></a><code>RpcServer</code></h4><p>属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置信息</span></span><br><span class="line"><span class="keyword">private</span> RpcServerConfig config;</span><br><span class="line"><span class="comment">// 网络模块</span></span><br><span class="line"><span class="keyword">private</span> TransportServer net;</span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">private</span> Encoder encoder;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">private</span> Decoder decoder;</span><br><span class="line"><span class="comment">// 管理服务</span></span><br><span class="line"><span class="keyword">private</span> ServiceManager serviceManager;</span><br><span class="line"><span class="comment">// 调用服务</span></span><br><span class="line"><span class="keyword">private</span> ServiceInvoker serviceInvoker;</span><br></pre></td></tr></table></figure>

<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> RpcServerConfig());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">(RpcServerConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="comment">// 创建网络模块</span></span><br><span class="line">    <span class="keyword">this</span>.net = ReflectionUtils.newInstance(config.getTransportClass());</span><br><span class="line">    <span class="keyword">this</span>.net.init(config.getPort(), <span class="keyword">this</span>.handler);	<span class="comment">// 初始化，这里需要创建一个Handler</span></span><br><span class="line">    <span class="comment">// 序列化与反序列化</span></span><br><span class="line">    <span class="keyword">this</span>.encoder = ReflectionUtils.newInstance(config.getEncoderClass());</span><br><span class="line">    <span class="keyword">this</span>.decoder = ReflectionUtils.newInstance(config.getDecoderClass());</span><br><span class="line">    <span class="comment">// 管理、调用服务</span></span><br><span class="line">    <span class="keyword">this</span>.serviceManager = <span class="keyword">new</span> ServiceManager();</span><br><span class="line">    <span class="keyword">this</span>.serviceInvoker = <span class="keyword">new</span> ServiceInvoker();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RequestHandler handler = <span class="keyword">new</span> RequestHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequest</span><span class="params">(InputStream receive, OutputStream toResp)</span> </span>&#123;</span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、从receive中读取request的数据体（request请求被序列化后的二进制数据）</span></span><br><span class="line">            <span class="keyword">byte</span>[] inBytes = IOUtils.readFully(receive, receive.available());</span><br><span class="line">            Request request = decoder.decode(inBytes, Request.class);</span><br><span class="line">            log.info(<span class="string">&quot;get request: &#123;&#125;&quot;</span>, request);</span><br><span class="line">            <span class="comment">// 2、得到Request就得到了服务，通过serviceInvoker调用服务拿到数据</span></span><br><span class="line">            <span class="comment">// 先通过服务管理类ServiceManager拿到service实例</span></span><br><span class="line">            ServiceInstance serviceInstance = serviceManager.lookup(request);</span><br><span class="line">            <span class="comment">// 再通过调用服务类的ServiceInvoker的invoker方法进行调用service实例的方法</span></span><br><span class="line">            Object ret = serviceInvoker.invoke(serviceInstance, request);</span><br><span class="line">            <span class="comment">// 把得到的结果写到response里</span></span><br><span class="line">            response.setData(ret);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(e.getMessage(), e);</span><br><span class="line">            <span class="comment">// 调用失败了</span></span><br><span class="line">            <span class="comment">// 在response里设置错误信息</span></span><br><span class="line">            response.setCode(<span class="number">1</span>);</span><br><span class="line">            response.setMessage(<span class="string">&quot;RpcServer got error: &quot;</span> + e.getClass().getName() + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 3、最后通过toResp把数据写回去，返回到客户端</span></span><br><span class="line">            <span class="comment">// 把Response序列化，然后写到toResp里</span></span><br><span class="line">            <span class="keyword">byte</span>[] outBytes = encoder.encode(response);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                toResp.write(outBytes);</span><br><span class="line">                log.info(<span class="string">&quot;response client&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.warn(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注册</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;T&gt; interfaceClass, T bean)</span> </span>&#123;</span><br><span class="line">    serviceManager.register(interfaceClass, bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动网络模块，等待监听</span></span><br><span class="line">    <span class="keyword">this</span>.net.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.net.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="client"><a href="#client" class="headerlink" title="client"></a><code>client</code></h3><p>依赖</p>
<ul>
<li><code>proto</code></li>
<li><code>codec</code></li>
<li><code>common</code></li>
<li><code>transport</code></li>
<li><code>commons-io</code></li>
</ul>
<h4 id="TransportSelector选择接口"><a href="#TransportSelector选择接口" class="headerlink" title="TransportSelector选择接口"></a><code>TransportSelector</code>选择接口</h4><p>路由选择，表示选择连接哪个server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransportSelector</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化selector</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> peers 可以连接的server端点列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count client与server建立多少个连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz client的实现class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(List&lt;Peer&gt; peers, <span class="keyword">int</span> count, Class&lt;? extends TransportClient&gt; clazz)</span></span>;</span><br><span class="line">    <span class="comment">// 选一个transport和server做交互，返回一个网络client</span></span><br><span class="line">    <span class="function">TransportClient <span class="title">select</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 释放用完的client</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(TransportClient client)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭selector</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RandomTransportSelector选择器实现类"><a href="#RandomTransportSelector选择器实现类" class="headerlink" title="RandomTransportSelector选择器实现类"></a><code>RandomTransportSelector</code>选择器实现类</h4><p><em>这些方法有可能并发执行，所以每一个方法加上synchronized</em>，保证线程安全</p>
<p><strong>全局变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已经连接好的clients</span></span><br><span class="line"><span class="keyword">private</span> List&lt;TransportClient&gt; clients;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RandomTransportSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    clients = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>init</code>实现</strong></p>
<p>把传进去的所有peer都和Client建立连接，放到clients集合里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(List&lt;Peer&gt; peers, <span class="keyword">int</span> count, Class&lt;? extends TransportClient&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// count必须大于等于1</span></span><br><span class="line">    count = Math.max(count, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 循环建立连接</span></span><br><span class="line">    <span class="keyword">for</span> (Peer peer : peers) &#123;</span><br><span class="line">        <span class="comment">// 遍历每个peer</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            TransportClient client = ReflectionUtils.newInstance(clazz);</span><br><span class="line">            client.connect(peer);</span><br><span class="line">            clients.add(client);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;connect server: &#123;&#125;&quot;</span>, peer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>选择连接</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> TransportClient <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机选择一个client列表中的client</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt(clients.size());</span><br><span class="line">    <span class="keyword">return</span> clients.remove(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>释放</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(TransportClient client)</span> </span>&#123;</span><br><span class="line">    clients.add(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关闭</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有client关闭</span></span><br><span class="line">    <span class="keyword">for</span> (TransportClient client : clients) &#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">    clients.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RpcClientConfig配置类"><a href="#RpcClientConfig配置类" class="headerlink" title="RpcClientConfig配置类"></a><code>RpcClientConfig</code>配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用哪个网络模块实现</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends TransportClient&gt; transportClass = HttpTransportClient.class;</span><br><span class="line">    <span class="comment">// 序列化和反序列化的配置信息</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends Encoder&gt; encoderClass = JSONEncoder.class;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends Decoder&gt; decoderClass = JSONDecoder.class;</span><br><span class="line">    <span class="comment">// 路由选择策略信息（默认随机策略）</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends TransportSelector&gt; selectorClass = RandomTransportSelector.class;</span><br><span class="line">    <span class="comment">// 每一个server的peer需要建立多少连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connectCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 可以连哪些网络端点</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Peer&gt; servers = Arrays.asList(<span class="keyword">new</span> Peer(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">3000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RpcClient"><a href="#RpcClient" class="headerlink" title="RpcClient"></a><code>RpcClient</code></h4><p><strong>属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RpcClientConfig config;</span><br><span class="line"><span class="keyword">private</span> Encoder encoder;</span><br><span class="line"><span class="keyword">private</span> Decoder decoder;</span><br><span class="line"><span class="keyword">private</span> TransportSelector selector;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造使用默认配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RpcClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> RpcClientConfig());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RpcClient</span><span class="params">(RpcClientConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="comment">// 把组件初始化</span></span><br><span class="line">    <span class="keyword">this</span>.encoder = ReflectionUtils.newInstance(<span class="keyword">this</span>.config.getEncoderClass());</span><br><span class="line">    <span class="keyword">this</span>.decoder = ReflectionUtils.newInstance(<span class="keyword">this</span>.config.getDecoderClass());</span><br><span class="line">    <span class="keyword">this</span>.selector = ReflectionUtils.newInstance(<span class="keyword">this</span>.config.getSelectorClass());</span><br><span class="line">    <span class="comment">// selector需要初始化</span></span><br><span class="line">    <span class="keyword">this</span>.selector.init(<span class="keyword">this</span>.config.getServers(), <span class="keyword">this</span>.config.getConnectCount(), <span class="keyword">this</span>.config.getTransportClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取接口的代理对象</strong></p>
<p>期待的是返回clazz子类的对象，所以使用泛型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(getClass().getClassLoader(), <span class="keyword">new</span> Class[]&#123;clazz&#125;, <span class="keyword">new</span> RemoteInvoker(clazz, encoder, decoder, selector));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK自带代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>

<p>第三个参数是<code>InvocationHandler</code>，这里使用<code>new RemoteInvoker(clazz, encoder, decoder, selector)</code>，自己创建的<code>Handler</code></p>
<h4 id="RemoteInvoker代理类"><a href="#RemoteInvoker代理类" class="headerlink" title="RemoteInvoker代理类"></a><code>RemoteInvoker</code>代理类</h4><p>调用远程服务的代理类，实现<code>InvocationHandler</code>接口，实现<code>invoke</code>方法</p>
<p><strong>属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远程服务的class信息</span></span><br><span class="line"><span class="keyword">private</span> Class clazz;</span><br><span class="line"><span class="comment">// 序列化和反序列化</span></span><br><span class="line"><span class="keyword">private</span> Encoder encoder;</span><br><span class="line"><span class="keyword">private</span> Decoder decoder;</span><br><span class="line"><span class="comment">// 选择远程网络连接</span></span><br><span class="line"><span class="keyword">private</span> TransportSelector selector;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RemoteInvoker</span><span class="params">(Class clazz, Encoder encoder, Decoder decoder, TransportSelector selector)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    <span class="keyword">this</span>.encoder = encoder;</span><br><span class="line">    <span class="keyword">this</span>.decoder = decoder;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>invoke</code>方法</strong></p>
<p>如果要调远程服务</p>
<ol>
<li>先要构造一个请求</li>
<li>通过网络把请求发送给server</li>
<li>发送完后等待server的响应</li>
<li>从响应里拿到返回的数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request();</span><br><span class="line">    <span class="comment">// request需要设置服务描述和参数</span></span><br><span class="line">    request.setService(ServiceDescriptor.from(clazz, method));</span><br><span class="line">    request.setParameters(args);</span><br><span class="line">    <span class="comment">// 通过网络传输调用远程服务</span></span><br><span class="line">    <span class="comment">// 把request传过去，server响应一个response</span></span><br><span class="line">    Response response = invokeRemote(request);</span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span> || response.getCode() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;fail to invoke remote: &quot;</span> + response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response.getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把网络通信invokeRemote写成一个方法，传进去request请求，得到response响应</p>
<p><strong><code>invokeRemote</code>实现网络传输</strong></p>
<p>根据request进行远程调用然后得到request返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Response <span class="title">invokeRemote</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    Response response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 网络连接信息</span></span><br><span class="line">    TransportClient client = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 选一个client</span></span><br><span class="line">        client = selector.select();</span><br><span class="line">        <span class="comment">// 序列化request</span></span><br><span class="line">        <span class="keyword">byte</span>[] outBytes = encoder.encode(request);</span><br><span class="line">        <span class="comment">// 获取到数据</span></span><br><span class="line">        InputStream receive = client.write(<span class="keyword">new</span> ByteArrayInputStream(outBytes));</span><br><span class="line">        <span class="comment">// 读出接收到的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] inBytes = IOUtils.readFully(receive, receive.available());</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        response = decoder.decode(inBytes, Response.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.warn(e.getMessage(), e);</span><br><span class="line">        response = <span class="keyword">new</span> Response();</span><br><span class="line">        response.setCode(<span class="number">1</span>);</span><br><span class="line">        response.setMessage(<span class="string">&quot;RpcClient got error: &quot;</span> + e.getClass() + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 放回池子里</span></span><br><span class="line">            selector.release(client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RPC使用"><a href="#RPC使用" class="headerlink" title="RPC使用"></a><code>RPC</code>使用</h2><p>依赖</p>
<ul>
<li>client</li>
<li>server</li>
</ul>
<h3 id="CalculatorService接口"><a href="#CalculatorService接口" class="headerlink" title="CalculatorService接口"></a><code>CalculatorService</code>接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CalculatorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CalculatorServiceImpl实现计算器"><a href="#CalculatorServiceImpl实现计算器" class="headerlink" title="CalculatorServiceImpl实现计算器"></a><code>CalculatorServiceImpl</code>实现计算器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorServiceImpl</span> <span class="keyword">implements</span> <span class="title">CalculatorService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a><code>Client</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> RpcClient();</span><br><span class="line">        <span class="comment">// 拿到远程代理对象</span></span><br><span class="line">        CalculatorService service = client.getProxy(CalculatorService.class);</span><br><span class="line">        <span class="keyword">int</span> r1 = service.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> r2 = service.minus(<span class="number">10</span>, <span class="number">8</span>);</span><br><span class="line">        System.out.println(r1);</span><br><span class="line">        System.out.println(r2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a><code>Server</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcServer server = <span class="keyword">new</span> RpcServer();</span><br><span class="line">        <span class="comment">// 注册服务</span></span><br><span class="line">        server.register(CalculatorService.class, <span class="keyword">new</span> CalculatorServiceImpl());</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>协议制定（网络里该传输什么：request、response，表示网络端点：peer）</li>
<li>序列化模块</li>
<li>网络传输</li>
<li>服务端</li>
<li>客户端</li>
</ul>
<h2 id="难点1：jetty嵌入"><a href="#难点1：jetty嵌入" class="headerlink" title="难点1：jetty嵌入"></a>难点1：jetty嵌入</h2><ul>
<li><code>Server</code>：网络监听</li>
<li><code>ServletContextHandler</code>：基于<code>Servlet</code>做网络处理，需要把<code>ServletContextHandler</code>注册到<code>JettyServler</code></li>
<li><code>ServletHolder</code>：托管<code>Servlet</code></li>
</ul>
<p>在<code>transport</code>模块下的<code>HttpTransportServer</code>类中，初始化的时候新建了一个<code>Jetty</code>的<code>Server</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.server = <span class="keyword">new</span> Server(port);</span><br></pre></td></tr></table></figure>

<p>创建<code>ServletContextHandler</code>，注册到<code>Server</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServletContextHandler ctx = <span class="keyword">new</span> ServletContextHandler();</span><br><span class="line">server.setHandler(ctx);</span><br></pre></td></tr></table></figure>

<p>使用<code>ServletHolder</code>托管<code>RequestServlet</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletHolder holder = <span class="keyword">new</span> ServletHolder(<span class="keyword">new</span> RequestServlet());</span><br></pre></td></tr></table></figure>

<p>数据的接收和写回都是<code>RequestServlet</code>中完成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要处理post请求，重写一下</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;client connected!&quot;</span>);</span><br><span class="line">        ServletInputStream in = req.getInputStream();</span><br><span class="line">        OutputStream out = resp.getOutputStream();</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handler.onRequest(in, out);</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="难点2：动态代理"><a href="#难点2：动态代理" class="headerlink" title="难点2：动态代理"></a>难点2：动态代理</h2><ul>
<li><code>Proxy.newProxyInstance</code></li>
<li><code>RemoteInvoker implements InvocationHandler</code></li>
</ul>
<p>在client模块中的<code>RpcClient</code>类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取接口的代理对象</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">            getClass().getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;clazz&#125;,</span><br><span class="line">            <span class="keyword">new</span> RemoteInvoker(clazz, encoder, decoder, selector));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自己实现的<code>RemoteInvoker</code>：</p>
<p>最关键的是invoke方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request();</span><br><span class="line">    request.setService(ServiceDescriptor.from(clazz, method));</span><br><span class="line">    request.setParameters(args);</span><br><span class="line">    <span class="comment">// 通过网络传输调用远程服务</span></span><br><span class="line">    <span class="comment">// 把request传过去，server响应一个response</span></span><br><span class="line">    Response response = invokeRemote(request);</span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span> || response.getCode() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;fail to invoke remote: &quot;</span> + response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response.getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不足与展望"><a href="#不足与展望" class="headerlink" title="不足与展望"></a>不足与展望</h2><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>基于<code>JSON</code>序列化做数据传输，网络通道未做安全校验</p>
<ul>
<li>可以使用HTTPS</li>
<li>序列化加密</li>
<li>网络连接做身份验证</li>
</ul>
<h3 id="服务端处理能力"><a href="#服务端处理能力" class="headerlink" title="服务端处理能力"></a>服务端处理能力</h3><p>实现<code>ServerTransport</code>的时候基于<code>jetty</code></p>
<p><code>jetty</code>有线程池处理<code>client</code>请求。上线的话，线程池最好自己去做。线程返回数据的通道最好做成队列</p>
<h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>对于<code>Server</code>地址的注册，<code>Client</code>自动发现<code>Server</code>地址</p>
<h3 id="集成能力"><a href="#集成能力" class="headerlink" title="集成能力"></a>集成能力</h3><p>如何与各个框架做嵌入</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hco3o.xyz/2021/10/07/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hco3o's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/07/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-07T18:06:19+08:00">
                2021-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hco3o</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
